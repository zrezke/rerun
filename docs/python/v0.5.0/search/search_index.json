{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"writing_docs/","title":"Python Docs","text":"<p>A high-level overview of writing and previewing the Rerun python documentation.</p>"},{"location":"writing_docs/#getting-started-with-docs","title":"Getting started with docs","text":""},{"location":"writing_docs/#dependencies","title":"Dependencies","text":"<p>All of the dependencies for documentation generation are captured in the requirements file: <pre><code>pip install -r rerun_py/requirements-doc.txt\n</code></pre></p>"},{"location":"writing_docs/#serving-the-docs-locally","title":"Serving the docs locally","text":"<p>The docs can be previewed locally using <code>mkdocs</code></p> <p>This will watch the contents of the <code>rerun_py</code> folder and refresh documentation live as files are changed. <pre><code>mkdocs serve -f rerun_py/mkdocs.yml -w rerun_py\n</code></pre> or <pre><code>just py-docs-serve\n</code></pre></p>"},{"location":"writing_docs/#how-versioned-docs-are-generated-and-served","title":"How versioned docs are generated and served","text":"<p>Our documentation is versioned with releases and generated via mike</p> <p>The documentation exists as a GitHub Pages project which is hosted from the contents of the <code>gh-pages</code> branch.</p> <p><code>mike</code> updates this branch with new content as part of CI</p> <p>Every commit that lands to main will generate bleeding edge documentation as HEAD. Behind the scenes, a GitHub action is just running: <pre><code>mike deploy -F rerun_py/mkdocs.yml HEAD\n</code></pre></p> <p>On release, when GitHub sees a new tag: <code>X.Y.Z</code>, the GitHub action will instead deploy with a version tag: <pre><code>mike deploy -F rerun_py/mkdocs.yml X.Y.Z latest\n</code></pre></p> <p>You can also locally preview the publicly hosted site with all versions, using mike: <pre><code>mike serve -F rerun_py/mkdocs.yml\n</code></pre> though when locally developing docs you are better off using <code>mkdocs serve</code> as described above since it will handle hot-reloading for you as you edit.</p>"},{"location":"common/","title":"Getting Started","text":"<ul> <li>Quick start</li> <li>Tutorial</li> <li>Examples on GitHub</li> <li>Troubleshooting</li> </ul> <p>There are many different ways of sending data to the Depthai Viewer depending on what you're trying to achieve and whether the viewer is running in the same process as your code, in another process, or even as a separate web application.</p> <p>Checkout SDK Operating Modes for an overview of what's possible and how.</p>"},{"location":"common/#apis","title":"APIs","text":""},{"location":"common/#initialization","title":"Initialization","text":"Function Description <code>rerun.init()</code> Initialize the Rerun SDK with a user-chosen application id (name). <code>rerun.connect()</code> Connect to a remote Depthai Viewer on the given ip:port. <code>rerun.disconnect()</code> Closes all TCP connections, servers, and files. <code>rerun.spawn()</code> Spawn a Depthai Viewer, listening on the given port. <code>rerun.serve()</code> Serve log-data over WebSockets and serve a Rerun web viewer over HTTP. <code>rerun.memory_recording()</code> Streams all log-data to a memory buffer."},{"location":"common/#viewer-control","title":"Viewer Control","text":"Function Description <code>rerun.set_recording_id()</code> Set the recording ID that this process is logging to, as a UUIDv4. <code>rerun.save()</code> Stream all log-data to a file."},{"location":"common/#time","title":"Time","text":"Function Description <code>rerun.set_time_sequence()</code> Set the current time for this thread as an integer sequence. <code>rerun.set_time_seconds()</code> Set the current time for this thread in seconds. <code>rerun.set_time_nanos()</code> Set the current time for this thread."},{"location":"common/#spatial-primitives","title":"Spatial Primitives","text":"Function Description <code>rerun.log_point()</code> Log a 2D or 3D point, with a position and optional color, radii, label, etc. <code>rerun.log_points()</code> Log 2D or 3D points, with positions and optional colors, radii, labels, etc. <code>rerun.log_rect()</code> Log a 2D rectangle. <code>rerun.log_rects()</code> Log multiple 2D rectangles. <code>rerun.log_obb()</code> Log a 3D Oriented Bounding Box, or OBB. <code>rerun.log_line_strip()</code> Log a line strip through 2D or 3D space. <code>rerun.log_line_segments()</code> Log many 2D or 3D line segments. <code>rerun.log_arrow()</code> Log a 3D arrow. <code>rerun.log_mesh()</code> Log a raw 3D mesh by specifying its vertex positions, and optionally indices, normals and albedo factor. <code>rerun.log_meshes()</code> Log multiple raw 3D meshes by specifying their different buffers and albedo factors. <code>rerun.log_mesh_file()</code> Log the contents of a mesh file (.gltf, .glb, .obj, \u2026)."},{"location":"common/#images","title":"Images","text":"Function Description <code>rerun.log_image()</code> Log a gray or color image. <code>rerun.log_image_file()</code> Log an image file given its contents or path on disk. <code>rerun.log_depth_image()</code> Log a depth image. <code>rerun.log_segmentation_image()</code> Log an image made up of integer class-ids."},{"location":"common/#tensors","title":"Tensors","text":"Function Description <code>rerun.log_tensor()</code> Log an n-dimensional tensor."},{"location":"common/#annotations","title":"Annotations","text":"Function Description <code>rerun.log_annotation_context()</code> Log an annotation context made up of a collection of ClassDescriptions."},{"location":"common/#extension-components","title":"Extension Components","text":"Function Description <code>rerun.log_extension_components()</code> Log an arbitrary collection of extension components."},{"location":"common/#plotting","title":"Plotting","text":"Function Description <code>rerun.log_scalar()</code> Log a double-precision scalar that will be visualized as a timeseries plot."},{"location":"common/#transforms","title":"Transforms","text":"Function Description <code>rerun.log_rigid3()</code> Log a proper rigid 3D transform between this entity and the parent. <code>rerun.log_pinhole()</code> Log a perspective camera model. <code>rerun.log_unknown_transform()</code> Log that this entity is NOT in the same space as the parent, but you do not (yet) know how they relate. <code>rerun.log_view_coordinates()</code> Log the view coordinates for an entity."},{"location":"common/#text","title":"Text","text":"Function Description <code>rerun.log_text_entry()</code> Log a text entry, with optional level."},{"location":"common/#helpers","title":"Helpers","text":"Function Description <code>rerun.script_add_args()</code> Add common Rerun script arguments to <code>parser</code>. <code>rerun.script_setup()</code> Run common Rerun script setup actions. Connect to the viewer if necessary. <code>rerun.script_teardown()</code> Run common post-actions. Sleep if serving the web viewer."},{"location":"common/#troubleshooting","title":"Troubleshooting","text":"<p>You can set <code>RUST_LOG=debug</code> before running your Python script and/or <code>rerun</code> process to get some verbose logging output.</p> <p>If you run into any issues don't hesitate to open a ticket or join our Discord.</p>"},{"location":"common/annotations/","title":"Annotations","text":""},{"location":"common/annotations/#rerun.log_annotation_context","title":"<code>def rerun.log_annotation_context(entity_path, class_descriptions, *, timeless=True)</code>","text":"<p>Log an annotation context made up of a collection of ClassDescriptions.</p> <p>Any entity needing to access the annotation context will find it by searching the path upward. If all entities share the same you can simply log it to the root (\"/\"), or if you want a per-entity ClassDescriptions log it to the same path as your entity.</p> <p>Each ClassDescription must include an annotation info with an id, which will be used for matching the class and may optionally include a label and color. Colors should either be in 0-255 gamma space or in 0-1 gamma space. Colors can be RGB or RGBA.</p> <p>These can either be specified verbosely as: <pre><code>[AnnotationInfo(id=23, label='foo', color=(255, 0, 0)), ...]\n</code></pre></p> <p>Or using short-hand tuples. <pre><code>[(23, 'bar'), ...]\n</code></pre></p> <p>Unspecified colors will be filled in by the visualizer randomly.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the annotation context in the space hierarchy.</p> required <code>class_descriptions</code> <code>Union[ClassDescriptionLike, Iterable[ClassDescriptionLike]]</code> <p>A single ClassDescription or a collection of ClassDescriptions.</p> required <code>timeless</code> <code>bool</code> <p>If true, the annotation context will be timeless (default: True).</p> <code>True</code>"},{"location":"common/extension_components/","title":"Extension Components","text":""},{"location":"common/extension_components/#rerun.log_extension_components","title":"<code>def rerun.log_extension_components(entity_path, ext, *, identifiers=None, timeless=False)</code>","text":"<p>Log an arbitrary collection of extension components.</p> <p>Each item in <code>ext</code> will be logged as a separate component.</p> <ul> <li>The key will be used as the name of the component</li> <li>The value must be able to be converted to an array of arrow types. In general, if    you can pass it to pyarrow.array,    you can log it as a extension component.</li> </ul> <p>All values must either have the same length, or be singular in which case they will be treated as a splat.</p> <p>Extension components will be prefixed with \"ext.\" to avoid collisions with rerun native components. You do not need to include this prefix; it will be added for you.</p> <p>Note: rerun requires that a given component only take on a single type. The first type logged will be the type that is used for all future logs of that component. The API will make a best effort to do type conversion if supported by numpy and arrow. Any components that can't be converted will be dropped.</p> <p>If you are want to inspect how your component will be converted to the underlying arrow code, the following snippet is what is happening internally: <pre><code>np_value = np.atleast_1d(np.array(value, copy=False))\npa_value = pa.array(value)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the extension components in the space hierarchy.</p> required <code>ext</code> <code>Dict[str, Any]</code> <p>A dictionary of extension components.</p> required <code>identifiers</code> <code>Optional[Sequence[int]]</code> <p>Optional identifiers for each component. If provided, must be the same length as the components.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the components will be timeless (default: False).</p> <code>False</code>"},{"location":"common/helpers/","title":"Helpers","text":"<p>Helper functions for Rerun scripts.</p> <p>These helper functions can be used to wire up common Rerun features to your script CLi arguments.</p>"},{"location":"common/helpers/#rerun.script_helpers--example","title":"Example","text":"<pre><code>import argparse\nimport rerun as rr\n\nparser = argparse.ArgumentParser()\nrr.script_add_args(parser)\nargs = parser.parse_args()\nrr.script_setup(args, \"my_application\")\n# ... Run your logging code here ...\nrr.script_teardown(args)\n</code></pre>"},{"location":"common/helpers/#rerun.script_add_args","title":"<code>def rerun.script_add_args(parser)</code>","text":"<p>Add common Rerun script arguments to <code>parser</code>.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The parser to add arguments to.</p> required"},{"location":"common/helpers/#rerun.script_setup","title":"<code>def rerun.script_setup(args, application_id)</code>","text":"<p>Run common Rerun script setup actions. Connect to the viewer if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>The parsed arguments from <code>parser.parse_args()</code>.</p> required <code>application_id</code> <code>str</code> <p>The application ID to use for the viewer.</p> required"},{"location":"common/helpers/#rerun.script_teardown","title":"<code>def rerun.script_teardown(args)</code>","text":"<p>Run common post-actions. Sleep if serving the web viewer.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>The parsed arguments from <code>parser.parse_args()</code>.</p> required"},{"location":"common/images/","title":"Images","text":""},{"location":"common/images/#rerun.log_image","title":"<code>def rerun.log_image(entity_path, image, *, ext=None, timeless=False)</code>","text":"<p>Log a gray or color image.</p> <p>The image should either have 1, 3 or 4 channels (gray, RGB or RGBA).</p>"},{"location":"common/images/#rerun.log_image--supported-dtypes","title":"Supported dtypes","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>uint16: color components should be in 0-65535 sRGB gamma space, except for alpha which should be in 0-65535 linear space.</li> <li>float32, float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the image to log.</p> required <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"common/images/#rerun.log_image_file","title":"<code>def rerun.log_image_file(entity_path, *, img_bytes=None, img_path=None, img_format=None, timeless=False)</code>","text":"<p>Log an image file given its contents or path on disk.</p> <p>Only JPEGs are supported right now.</p> <p>You must pass either <code>img_bytes</code> or <code>img_path</code>.</p> <p>If no <code>img_format</code> is specified, we will try and guess it.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>img_bytes</code> <code>Optional[bytes]</code> <p>Content of an image file, e.g. a <code>.jpg</code>.</p> <code>None</code> <code>img_path</code> <code>Optional[Path]</code> <p>Path to an image file, e.g. a <code>.jpg</code>.</p> <code>None</code> <code>img_format</code> <code>Optional[ImageFormat]</code> <p>Format of the image file.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"common/images/#rerun.log_depth_image","title":"<code>def rerun.log_depth_image(entity_path, image, *, meter=None, ext=None, timeless=False)</code>","text":"<p>Log a depth image.</p> <p>The image must be a 2D array.</p>"},{"location":"common/images/#rerun.log_depth_image--supported-dtypes","title":"Supported dtypes","text":"<p>uint8, uint16, float32, float64</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the depth image to log.</p> required <code>meter</code> <code>Optional[float]</code> <p>How long is a meter in the given dtype? For instance: with uint16, perhaps meter=1000 which would mean you have millimeter precision and a range of up to ~65 meters (2^16 / 1000).</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"common/images/#rerun.log_segmentation_image","title":"<code>def rerun.log_segmentation_image(entity_path, image, *, ext=None, timeless=False)</code>","text":"<p>Log an image made up of integer class-ids.</p> <p>The image should have 1 channel, i.e. be either <code>H x W</code> or <code>H x W x 1</code>.</p> <p>See: rerun.log_annotation_context for information on how to map the class-ids to colors and labels.</p>"},{"location":"common/images/#rerun.log_segmentation_image--supported-dtypes","title":"Supported dtypes","text":"<p>uint8, uint16</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>npt.ArrayLike</code> <p>A Tensor representing the segmentation image to log.</p> required <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"common/initialization/","title":"Initialization","text":""},{"location":"common/initialization/#rerun.init","title":"<code>def rerun.init(application_id, spawn=False, default_enabled=True, strict=False)</code>","text":"<p>Initialize the Rerun SDK with a user-chosen application id (name).</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>str</code> <p>Your Rerun recordings will be categorized by this application id, so try to pick a unique one for each application that uses the Rerun SDK.</p> <p>For example, if you have one application doing object detection and another doing camera calibration, you could have <code>rerun.init(\"object_detector\")</code> and <code>rerun.init(\"calibrator\")</code>.</p> required <code>spawn</code> <code>bool</code> <p>Spawn a Depthai Viewer and stream logging data to it. Short for calling <code>spawn</code> separately. If you don't call this, log events will be buffered indefinitely until you call either <code>connect</code>, <code>show</code>, or <code>save</code></p> <code>False</code> <code>default_enabled</code> <code>bool</code> <p>Should Rerun logging be on by default? Can overridden with the RERUN env-var, e.g. <code>RERUN=on</code> or <code>RERUN=off</code>.</p> <code>True</code> <code>strict</code> <code>bool</code> <p>If <code>True</code>, an exceptions is raised on use error (wrong parameter types etc). If <code>False</code>, errors are logged as warnings instead.</p> <code>False</code>"},{"location":"common/initialization/#rerun.connect","title":"<code>def rerun.connect(addr=None)</code>","text":"<p>Connect to a remote Depthai Viewer on the given ip:port.</p> <p>Requires that you first start a Depthai Viewer, e.g. with 'python -m rerun'</p> <p>This function returns immediately.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>Optional[str]</code> <p>The ip:port to connect to</p> <code>None</code>"},{"location":"common/initialization/#rerun.disconnect","title":"<code>def rerun.disconnect()</code>","text":"<p>Closes all TCP connections, servers, and files.</p> <p>Closes all TCP connections, servers, and files that have been opened with [<code>rerun.connect</code>], [<code>rerun.serve</code>], [<code>rerun.save</code>] or [<code>rerun.spawn</code>].</p>"},{"location":"common/initialization/#rerun.spawn","title":"<code>def rerun.spawn(port=9876, connect=True)</code>","text":"<p>Spawn a Depthai Viewer, listening on the given port.</p> <p>This is often the easiest and best way to use Rerun. Just call this once at the start of your program.</p> <p>You can also call rerun.init with a <code>spawn=True</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The port to listen on.</p> <code>9876</code> <code>connect</code> <code>bool</code> <p>also connect to the viewer and stream logging data to it.</p> <code>True</code>"},{"location":"common/initialization/#rerun.serve","title":"<code>def rerun.serve(open_browser=True, web_port=None, ws_port=None)</code>","text":"<p>Serve log-data over WebSockets and serve a Rerun web viewer over HTTP.</p> <p>You can connect to this server using <code>python -m rerun</code>.</p> <p>WARNING: This is an experimental feature.</p> <p>This function returns immediately.</p> <p>Parameters:</p> Name Type Description Default <code>open_browser</code> <code>bool</code> <p>Open the default browser to the viewer.</p> <code>True</code> <code>web_port</code> <code>Optional[int]</code> <p>The port to serve the web viewer on (defaults to 9090).</p> <code>None</code> <code>ws_port</code> <code>Optional[int]</code> <p>The port to serve the WebSocket server on (defaults to 9877)</p> <code>None</code>"},{"location":"common/initialization/#rerun.memory_recording","title":"<code>def rerun.memory_recording()</code>","text":"<p>Streams all log-data to a memory buffer.</p> <p>This can be used to display the RRD to alternative formats such as html. See: rerun.MemoryRecording.as_html.</p> <p>Returns:</p> Type Description <code>MemoryRecording</code> <p>A memory recording object that can be used to read the data.</p>"},{"location":"common/plotting/","title":"Plotting","text":""},{"location":"common/plotting/#rerun.log_scalar","title":"<code>def rerun.log_scalar(entity_path, scalar, *, label=None, color=None, radius=None, scattered=None, ext=None)</code>","text":"<p>Log a double-precision scalar that will be visualized as a timeseries plot.</p> <p>The current simulation time will be used for the time/X-axis, hence scalars cannot be timeless!</p> <p>See here for a larger example.</p>"},{"location":"common/plotting/#rerun.log_scalar--understanding-the-plot-and-attributes-hierarchy","title":"Understanding the plot and attributes hierarchy","text":"<p>Timeseries come in three parts: points, lines and finally the plots themselves. As a user of the Rerun SDK, your one and only entrypoint into that hierarchy is through the lowest-level layer: the points.</p> <p>When logging scalars and their attributes (label, color, radius, scattered) through this function, Rerun will turn them into points with similar attributes. From these points, lines with appropriate attributes can then be inferred; and from these inferred lines, plots with appropriate attributes will be inferred in turn!</p> <p>In terms of actual hierarchy:</p> <ul> <li>Each space represents a single plot.</li> <li>Each entity path within a space that contains scalar data is a line within that plot.</li> <li>Each logged scalar is a point.</li> </ul> <p>E.g. the following: <pre><code>t=1.0\nrerun.log_scalar(\"trig/sin\", math.sin(t), label=\"sin(t)\", color=[255, 0, 0])\nrerun.log_scalar(\"trig/cos\", math.cos(t), label=\"cos(t)\", color=[0, 0, 255])\n</code></pre> will yield a single plot (space = <code>trig</code>), comprised of two lines (entity paths <code>trig/sin</code> and <code>trig/cos</code>).</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the scalar in the space hierarchy.</p> required <code>scalar</code> <code>float</code> <p>The scalar value to log.</p> required <code>label</code> <code>Optional[str]</code> <p>An optional label for the point.</p> <p>This won't show up on points at the moment, as our plots don't yet support displaying labels for individual points TODO(https://github.com/rerun-io/rerun/issues/1289). If all points within a single entity path (i.e. a line) share the same label, then this label will be used as the label for the line itself. Otherwise, the line will be named after the entity path. The plot itself is named after the space it's in.</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <p>If left unspecified, a pseudo-random color will be used instead. That same color will apply to all points residing in the same entity path that don't have a color specified.</p> <p>Points within a single line do not have to share the same color, the line will have differently colored segments as appropriate. If all points within a single entity path (i.e. a line) share the same color, then this color will be used as the line color in the plot legend. Otherwise, the line will appear grey in the legend.</p> <code>None</code> <code>radius</code> <code>Optional[float]</code> <p>An optional radius for the point.</p> <p>Points within a single line do not have to share the same radius, the line will have differently sized segments as appropriate.</p> <p>If all points within a single entity path (i.e. a line) share the same radius, then this radius will be used as the line width too. Otherwise, the line will use the default width of <code>1.0</code>.</p> <code>None</code> <code>scattered</code> <code>Optional[bool]</code> <p>Specifies whether the point should form a continuous line with its neighbors, or whether it should stand on its own, akin to a scatter plot. Points within a single line do not have to all share the same scatteredness: the line will switch between a scattered and a continuous representation as required.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code>"},{"location":"common/spatial_primitives/","title":"Spatial Primitives","text":""},{"location":"common/spatial_primitives/#rerun.log_point","title":"<code>def rerun.log_point(entity_path, position=None, *, radius=None, color=None, label=None, class_id=None, keypoint_id=None, ext=None, timeless=False)</code>","text":"<p>Log a 2D or 3D point, with a position and optional color, radii, label, etc.</p> <p>Logging again to the same <code>entity_path</code> will replace the previous point.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA represented as a 2-element or 3-element sequence.</p>"},{"location":"common/spatial_primitives/#rerun.log_point--supported-dtypes-for-color","title":"Supported dtypes for <code>color</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the point in the space hierarchy.</p> required <code>position</code> <code>Optional[npt.ArrayLike]</code> <p>Any 2-element or 3-element array-like.</p> <code>None</code> <code>radius</code> <code>Optional[float]</code> <p>Optional radius (make it a sphere).</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text to show with the point.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the point. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_id</code> <code>Optional[int]</code> <p>Optional key point id for the point, identifying it within a class. If keypoint_id is passed but no class_id was specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the point will be timeless (default: False).</p> <code>False</code>"},{"location":"common/spatial_primitives/#rerun.log_points","title":"<code>def rerun.log_points(entity_path, positions=None, *, identifiers=None, colors=None, radii=None, labels=None, class_ids=None, keypoint_ids=None, ext=None, timeless=False)</code>","text":"<p>Log 2D or 3D points, with positions and optional colors, radii, labels, etc.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous points.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"common/spatial_primitives/#rerun.log_points--supported-dtypes-for-colors","title":"Supported dtypes for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the points in the space hierarchy.</p> required <code>positions</code> <code>Optional[npt.ArrayLike]</code> <p>Nx2 or Nx3 array</p> <code>None</code> <code>identifiers</code> <code>Optional[npt.ArrayLike]</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Optional[Union[Color, Colors]]</code> <p>Optional colors of the points. The colors are interpreted as RGB or RGBA in sRGB gamma-space, as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>radii</code> <code>Optional[npt.ArrayLike]</code> <p>Optional radii (make it a sphere).</p> <code>None</code> <code>labels</code> <code>Optional[Sequence[str]]</code> <p>Optional per-point text to show with the points</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the points. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_ids</code> <code>OptionalKeyPointIds</code> <p>Optional key point ids for the points, identifying them within a class. If keypoint_ids are passed in but no class_ids were specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the points will be timeless (default: False).</p> <code>False</code>"},{"location":"common/spatial_primitives/#rerun.log_rect","title":"<code>def rerun.log_rect(entity_path, rect, *, rect_format=RectFormat.XYWH, color=None, label=None, class_id=None, ext=None, timeless=False)</code>","text":"<p>Log a 2D rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangle in the space hierarchy.</p> required <code>rect</code> <code>Optional[npt.ArrayLike]</code> <p>the rectangle in [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text to show inside the rectangle.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the rectangle. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the rect will be timeless (default: False).</p> <code>False</code>"},{"location":"common/spatial_primitives/#rerun.log_rects","title":"<code>def rerun.log_rects(entity_path, rects, *, rect_format=RectFormat.XYWH, identifiers=None, colors=None, labels=None, class_ids=None, ext=None, timeless=False)</code>","text":"<p>Log multiple 2D rectangles.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous rectangles.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"common/spatial_primitives/#rerun.log_rects--supported-dtypes-for-colors","title":"Supported <code>dtype</code>s for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangles in the space hierarchy.</p> required <code>rects</code> <code>Optional[npt.ArrayLike]</code> <p>Nx4 numpy array, where each row is [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>identifiers</code> <code>Optional[Sequence[int]]</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Optional[Union[Color, Colors]]</code> <p>Optional per-rectangle gamma-space RGB or RGBA as 0-1 floats or 0-255 integers.</p> <code>None</code> <code>labels</code> <code>Optional[Sequence[str]]</code> <p>Optional per-rectangle text to show inside the rectangle.</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the rectangles. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the rects will be timeless (default: False).</p> <code>False</code>"},{"location":"common/spatial_primitives/#rerun.log_obb","title":"<code>def rerun.log_obb(entity_path, *, half_size, position=None, rotation_q=None, color=None, stroke_width=None, label=None, class_id=None, ext=None, timeless=False)</code>","text":"<p>Log a 3D Oriented Bounding Box, or OBB.</p>"},{"location":"common/spatial_primitives/#rerun.log_obb--example","title":"Example:","text":"<pre><code>rr.log_obb(\"my_obb\", half_size=[1.0, 2.0, 3.0], position=[0, 0, 0], rotation_q=[0, 0, 0, 1])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the oriented bounding box in the space hierarchy.</p> required <code>half_size</code> <code>Optional[npt.ArrayLike]</code> <p>Array with [x, y, z] half dimensions of the OBB.</p> required <code>position</code> <code>Optional[npt.ArrayLike]</code> <p>Optional array with [x, y, z] position of the OBB in world space.</p> <code>None</code> <code>rotation_q</code> <code>Optional[npt.ArrayLike]</code> <p>Optional array with quaternion coordinates [x, y, z, w] for the rotation from model to world space.</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>stroke_width</code> <code>Optional[float]</code> <p>Optional width of the line edges.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text label placed at <code>position</code>.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the OBB.  The class id provides colors and labels if not specified explicitly.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the bounding box will be timeless (default: False).</p> <code>False</code>"},{"location":"common/spatial_primitives/#rerun.log_line_strip","title":"<code>def rerun.log_line_strip(entity_path, positions, *, stroke_width=None, color=None, ext=None, timeless=False)</code>","text":"<p>Log a line strip through 2D or 3D space.</p> <p>A line strip is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so: <pre><code>       2------3     5\n      /        \\   /\n0----1          \\ /\n                 4\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the path in the space hierarchy</p> required <code>positions</code> <code>Optional[npt.ArrayLike]</code> <p>An Nx2 or Nx3 array of points along the path.</p> required <code>stroke_width</code> <code>Optional[float]</code> <p>Optional width of the line.</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the path will be timeless (default: False).</p> <code>False</code>"},{"location":"common/spatial_primitives/#rerun.log_line_segments","title":"<code>def rerun.log_line_segments(entity_path, positions, *, stroke_width=None, color=None, ext=None, timeless=False)</code>","text":"<p>Log many 2D or 3D line segments.</p> <p>The points will be connected in even-odd pairs, like so:</p> <pre><code>       2------3     5\n                   /\n0----1            /\n                 4\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the line segments in the space hierarchy</p> required <code>positions</code> <code>npt.ArrayLike</code> <p>An Nx2 or Nx3 array of points. Even-odd pairs will be connected as segments.</p> required <code>stroke_width</code> <code>Optional[float]</code> <p>Optional width of the line.</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the line segments will be timeless (default: False).</p> <code>False</code>"},{"location":"common/spatial_primitives/#rerun.log_arrow","title":"<code>def rerun.log_arrow(entity_path, origin, vector=None, *, color=None, label=None, width_scale=None, ext=None, timeless=False)</code>","text":"<p>Log a 3D arrow.</p> <p>An arrow is defined with an <code>origin</code>, and a <code>vector</code>. This can also be considered as <code>start</code> and <code>end</code> positions for the arrow.</p> <p>The shaft is rendered as a cylinder with <code>radius = 0.5 * width_scale</code>. The tip is rendered as a cone with <code>height = 2.0 * width_scale</code> and <code>radius = 1.0 * width_scale</code>.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to store the entity at.</p> required <code>origin</code> <code>Optional[npt.ArrayLike]</code> <p>The base position of the arrow.</p> required <code>vector</code> <code>Optional[npt.ArrayLike]</code> <p>The vector along which the arrow will be drawn.</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>An optional text to show beside the arrow.</p> <code>None</code> <code>width_scale</code> <code>Optional[float]</code> <p>An optional scaling factor, default=1.0.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>The entity is not time-dependent, and will be visible at any time point.</p> <code>False</code>"},{"location":"common/spatial_primitives/#rerun.log_mesh","title":"<code>def rerun.log_mesh(entity_path, positions, *, indices=None, normals=None, albedo_factor=None, vertex_colors=None, timeless=False)</code>","text":"<p>Log a raw 3D mesh by specifying its vertex positions, and optionally indices, normals and albedo factor.</p> <p>You can also use [<code>rerun.log_mesh_file</code>] to log .gltf, .glb, .obj, etc.</p>"},{"location":"common/spatial_primitives/#rerun.log_mesh--example","title":"Example:","text":"<pre><code># A simple red triangle:\nrerun.log_mesh(\n    \"world/mesh\",\n    positions = [\n        [0.0, 0.0, 0.0],\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0]\n    ],\n    indices = [0, 1, 2],\n    normals = [\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, 1.0]\n    ],\n    albedo_factor = [1.0, 0.0, 0.0],\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>positions</code> <code>Any</code> <p>An array of 3D points. If no <code>indices</code> are specified, then each triplet of positions is interpreted as a triangle.</p> required <code>indices</code> <code>Optional[Any]</code> <p>If specified, is a flattened array of indices that describe the mesh's triangles, i.e. its length must be divisible by 3.</p> <code>None</code> <code>normals</code> <code>Optional[Any]</code> <p>If specified, is a (potentially flattened) array of 3D vectors that describe the normal for each vertex, i.e. the total number of elements must be divisible by 3 and more importantly, <code>len(normals)</code> should be equal to <code>len(positions)</code>.</p> <code>None</code> <code>albedo_factor</code> <code>Optional[Any]</code> <p>Optional color multiplier of the mesh using RGB or unmuliplied RGBA in linear 0-1 space.</p> <code>None</code> <code>vertex_colors</code> <code>Optional[Colors]</code> <p>Optional array of RGB(A) vertex colors, in sRGB gamma space, either as 0-1 floats or 0-255 integers. If specified, the alpha is considered separate (unmultiplied).</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code>"},{"location":"common/spatial_primitives/#rerun.log_meshes","title":"<code>def rerun.log_meshes(entity_path, position_buffers, *, vertex_color_buffers, index_buffers, normal_buffers, albedo_factors, timeless=False)</code>","text":"<p>Log multiple raw 3D meshes by specifying their different buffers and albedo factors.</p> <p>To learn more about how the data within these buffers is interpreted and laid out, refer to the documentation for [<code>rerun.log_mesh</code>].</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>position_buffers</code> <code>Sequence[npt.ArrayLike]</code> <p>A sequence of position buffers, one for each mesh.</p> required <code>vertex_color_buffers</code> <code>Sequence[Optional[Colors]]</code> <p>An optional sequence of vertex color buffers, one for each mesh.</p> required <code>index_buffers</code> <code>Sequence[Optional[npt.ArrayLike]]</code> <p>An optional sequence of index buffers, one for each mesh.</p> required <code>normal_buffers</code> <code>Sequence[Optional[npt.ArrayLike]]</code> <p>An optional sequence of normal buffers, one for each mesh.</p> required <code>albedo_factors</code> <code>Sequence[Optional[npt.ArrayLike]]</code> <p>An optional sequence of albedo factors, one for each mesh.</p> required <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code>"},{"location":"common/spatial_primitives/#rerun.log_mesh_file","title":"<code>def rerun.log_mesh_file(entity_path, mesh_format, mesh_file, *, transform=None, timeless=False)</code>","text":"<p>Log the contents of a mesh file (.gltf, .glb, .obj, \u2026).</p> <p>You can also use [<code>rerun.log_mesh</code>] to log raw mesh data.</p>"},{"location":"common/spatial_primitives/#rerun.log_mesh_file--example","title":"Example:","text":"<pre><code># Move mesh 10 units along the X axis.\ntransform=np.array([\n    [1, 0, 0, 10],\n    [0, 1, 0, 0],\n    [0, 0, 1, 0]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>mesh_format</code> <code>MeshFormat</code> <p>Format of the mesh file</p> required <code>mesh_file</code> <code>bytes</code> <p>Contents of the mesh file</p> required <code>transform</code> <code>Optional[npt.ArrayLike]</code> <p>Optional 3x4 affine transform matrix applied to the mesh</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code>"},{"location":"common/tensors/","title":"Tensors","text":""},{"location":"common/tensors/#rerun.log_tensor","title":"<code>def rerun.log_tensor(entity_path, tensor, *, names=None, meter=None, ext=None, timeless=False)</code>","text":"<p>Log an n-dimensional tensor.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the tensor in the space hierarchy.</p> required <code>tensor</code> <code>npt.ArrayLike</code> <p>A Tensor object.</p> required <code>names</code> <code>Optional[Iterable[Optional[str]]]</code> <p>Optional names for each dimension of the tensor.</p> <code>None</code> <code>meter</code> <code>Optional[float]</code> <p>Optional scale of the tensor (e.g. meters per cell).</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the tensor will be timeless (default: False).</p> <code>False</code>"},{"location":"common/text/","title":"Text","text":""},{"location":"common/text/#rerun.log_text_entry","title":"<code>def rerun.log_text_entry(entity_path, text, *, level=LogLevel.INFO, color=None, ext=None, timeless=False)</code>","text":"<p>Log a text entry, with optional level.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The object path to log the text entry under.</p> required <code>text</code> <code>str</code> <p>The text to log.</p> required <code>level</code> <code>Optional[str]</code> <p>The level of the text entry (default: <code>LogLevel.INFO</code>). Note this can technically be an arbitrary string, but it's recommended to use one of the constants from LogLevel</p> <code>LogLevel.INFO</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>Whether the text entry should be timeless.</p> <code>False</code>"},{"location":"common/time/","title":"Time","text":""},{"location":"common/time/#rerun.set_time_sequence","title":"<code>def rerun.set_time_sequence(timeline, sequence)</code>","text":"<p>Set the current time for this thread as an integer sequence.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>set_time_sequence</code>.</p> <p>For example: <code>set_time_sequence(\"frame_nr\", frame_nr)</code>.</p> <p>You can remove a timeline again using <code>set_time_sequence(\"frame_nr\", None)</code>.</p> <p>There is no requirement of monotonicity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>sequence</code> <code>int</code> <p>The current time on the timeline in integer units.</p> required"},{"location":"common/time/#rerun.set_time_seconds","title":"<code>def rerun.set_time_seconds(timeline, seconds)</code>","text":"<p>Set the current time for this thread in seconds.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>rerun.set_time_seconds</code> or <code>rerun.set_time_nanos</code>.</p> <p>For example: <code>set_time_seconds(\"capture_time\", seconds_since_unix_epoch)</code>.</p> <p>You can remove a timeline again using <code>set_time_seconds(\"capture_time\", None)</code>.</p> <p>Very large values will automatically be interpreted as seconds since unix epoch (1970-01-01). Small values (less than a few years) will be interpreted as relative some unknown point in time, and will be shown as e.g. <code>+3.132s</code>.</p> <p>The bindings has a built-in time which is <code>log_time</code>, and is logged as seconds since unix epoch.</p> <p>There is no requirement of monotonicity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>seconds</code> <code>float</code> <p>The current time on the timeline in seconds.</p> required"},{"location":"common/time/#rerun.set_time_nanos","title":"<code>def rerun.set_time_nanos(timeline, nanos)</code>","text":"<p>Set the current time for this thread.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>rerun.set_time_nanos</code> or <code>rerun.set_time_seconds</code>.</p> <p>For example: <code>set_time_nanos(\"capture_time\", nanos_since_unix_epoch)</code>.</p> <p>You can remove a timeline again using <code>set_time_nanos(\"capture_time\", None)</code>.</p> <p>Very large values will automatically be interpreted as nanoseconds since unix epoch (1970-01-01). Small values (less than a few years) will be interpreted as relative some unknown point in time, and will be shown as e.g. <code>+3.132s</code>.</p> <p>The bindings has a built-in time which is <code>log_time</code>, and is logged as nanos since unix epoch.</p> <p>There is no requirement of monotonicity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>nanos</code> <code>int</code> <p>The current time on the timeline in nanoseconds.</p> required"},{"location":"common/transforms/","title":"Transforms","text":"<p>Methods for logging transforms on entity paths.</p> <p>Learn more about transforms in the manual</p>"},{"location":"common/transforms/#rerun.log_rigid3","title":"<code>def rerun.log_rigid3(entity_path, *, parent_from_child=None, child_from_parent=None, xyz='', timeless=False)</code>","text":"<p>Log a proper rigid 3D transform between this entity and the parent.</p> <p>Set either <code>parent_from_child</code> or <code>child_from_parent</code> to a tuple of <code>(translation_xyz, quat_xyzw)</code>.</p>"},{"location":"common/transforms/#rerun.log_rigid3--parent-from-child","title":"Parent-from-child","text":"<p>Also known as pose (e.g. camera extrinsics).</p> <p>The translation is the position of the entity in the parent space. The resulting transform from child to parent corresponds to taking a point in the child space, rotating it by the given rotations, and then translating it by the given translation:</p> <p><code>point_parent = translation + quat * point_child * quat*</code></p>"},{"location":"common/transforms/#rerun.log_rigid3--example","title":"Example","text":"<pre><code>t = 0.0\ntranslation = [math.sin(t), math.cos(t), 0.0] # circle around origin\nrotation = [0.5, 0.0, 0.0, np.sin(np.pi/3)] # 60 degrees around x-axis\nrerun.log_rigid3(\"sun/planet\", parent_from_child=(translation, rotation))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path of the child space in the space hierarchy.</p> required <code>parent_from_child</code> <code>Optional[Tuple[npt.ArrayLike, npt.ArrayLike]]</code> <p>A tuple of <code>(translation_xyz, quat_xyzw)</code> mapping points in the child space to the parent space.</p> <code>None</code> <code>child_from_parent</code> <code>Optional[Tuple[npt.ArrayLike, npt.ArrayLike]]</code> <p>the inverse of <code>parent_from_child</code></p> <code>None</code> <code>xyz</code> <code>str</code> <p>Optionally set the view coordinates of this entity, e.g. to <code>RDF</code> for <code>X=Right, Y=Down, Z=Forward</code>. This is a convenience for also calling log_view_coordinates.</p> <code>''</code> <code>timeless</code> <code>bool</code> <p>If true, the transform will be timeless (default: False).</p> <code>False</code>"},{"location":"common/transforms/#rerun.log_pinhole","title":"<code>def rerun.log_pinhole(entity_path, *, child_from_parent, width, height, timeless=False)</code>","text":"<p>Log a perspective camera model.</p> <p>This logs the pinhole model that projects points from the parent (camera) space to this space (image) such that: <pre><code>point_image_hom = child_from_parent * point_cam\npoint_image = point_image_hom[:,1] / point_image_hom[2]\n</code></pre></p> <p>Where <code>point_image_hom</code> is the projected point in the image space expressed in homogeneous coordinates.</p>"},{"location":"common/transforms/#rerun.log_pinhole--example","title":"Example","text":"<pre><code>width = 640\nheight = 480\nu_cen = width / 2\nv_cen = height / 2\nf_len = (height * width) ** 0.5\n\nrerun.log_pinhole(\"world/camera/image\",\n                  child_from_parent = [[f_len, 0,     u_cen],\n                                       [0,     f_len, v_cen],\n                                       [0,     0,     1  ]],\n                  width = width,\n                  height = height)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the child (image) space in the space hierarchy.</p> required <code>child_from_parent</code> <code>npt.ArrayLike</code> <p>Row-major intrinsics matrix for projecting from camera space to image space.</p> required <code>width</code> <code>int</code> <p>Width of the image in pixels.</p> required <code>height</code> <code>int</code> <p>Height of the image in pixels.</p> required <code>timeless</code> <code>bool</code> <p>If true, the camera will be timeless (default: False).</p> <code>False</code>"},{"location":"common/transforms/#rerun.log_unknown_transform","title":"<code>def rerun.log_unknown_transform(entity_path, timeless=False)</code>","text":"<p>Log that this entity is NOT in the same space as the parent, but you do not (yet) know how they relate.</p>"},{"location":"common/transforms/#rerun.log_view_coordinates","title":"<code>def rerun.log_view_coordinates(entity_path, *, xyz='', up='', right_handed=None, timeless=False)</code>","text":"<p>Log the view coordinates for an entity.</p> <p>Each entity defines its own coordinate system, called a space. By logging view coordinates you can give semantic meaning to the XYZ axes of the space. This is for example useful for camera entities (\"what axis is forward?\").</p> <p>For full control, set the <code>xyz</code> parameter to a three-letter acronym (<code>xyz=\"RDF\"</code>). Each letter represents:</p> <ul> <li>R: Right</li> <li>L: Left</li> <li>U: Up</li> <li>D: Down</li> <li>F: Forward</li> <li>B: Back</li> </ul> <p>Some of the most common are:</p> <ul> <li>\"RDF\": X=Right Y=Down Z=Forward  (right-handed)</li> <li>\"RUB\"  X=Right Y=Up   Z=Back     (right-handed)</li> <li>\"RDB\": X=Right Y=Down Z=Back     (left-handed)</li> <li>\"RUF\": X=Right Y=Up   Z=Forward  (left-handed)</li> </ul>"},{"location":"common/transforms/#rerun.log_view_coordinates--example","title":"Example","text":"<pre><code>rerun.log_view_coordinates(\"world/camera\", xyz=\"RUB\")\n</code></pre> <p>For world-coordinates it's often convenient to just specify an up-axis. You can do so by using the <code>up</code>-parameter (where <code>up</code> is one of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\"):</p> <pre><code>rerun.log_view_coordinates(\"world\", up=\"+Z\", right_handed=True, timeless=True)\nrerun.log_view_coordinates(\"world\", up=\"-Y\", right_handed=False, timeless=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path in the space hierarchy where the view coordinate will be set.</p> required <code>xyz</code> <code>str</code> <p>Three-letter acronym for the view coordinate axes.</p> <code>''</code> <code>up</code> <code>str</code> <p>Which axis is up? One of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\".</p> <code>''</code> <code>right_handed</code> <code>Optional[bool]</code> <p>If True, the coordinate system is right-handed. If False, it is left-handed.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the view coordinates will be timeless (default: False).</p> <code>False</code>"},{"location":"common/viewer_control/","title":"Viewer Control","text":""},{"location":"common/viewer_control/#rerun.set_recording_id","title":"<code>def rerun.set_recording_id(value)</code>","text":"<p>Set the recording ID that this process is logging to, as a UUIDv4.</p> <p>The default recording_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default recording_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same recording), you will need to manually assign them all the same recording_id. Any random UUIDv4 will work, or copy the recording id for the parent process.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The recording ID to use for this process.</p> required"},{"location":"common/viewer_control/#rerun.save","title":"<code>def rerun.save(path)</code>","text":"<p>Stream all log-data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the data to.</p> required"},{"location":"package/","title":"Full Package","text":"<ul> <li>rerun: Top-level User-facing APIs. See also: Common APIs<ul> <li>rerun.log: APIs for logging data</li> <li>rerun.color_conversion: Conversion utilities related to colors</li> <li>rerun.components: Helpers for constructing arrow components</li> </ul> </li> <li>rerun_demo: Utilities related to running rerun demos<ul> <li>rerun_demo.data: Specific helpers for generating data</li> </ul> </li> </ul>"},{"location":"package/rerun/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/__init__/#rerun","title":"<code>rerun</code>","text":"<p>The Rerun Python SDK, which is a wrapper around the re_sdk crate.</p>"},{"location":"package/rerun/__init__/#rerun.AnnotationInfo","title":"<code>class AnnotationInfo</code>  <code>dataclass</code>","text":"<p>Annotation info annotating a class id or key-point id.</p> <p>Color and label will be used to annotate entities/keypoints which reference the id. The id refers either to a class or key-point id</p>"},{"location":"package/rerun/__init__/#rerun.log.annotation.AnnotationInfo.id","title":"<code>id: int = 0</code>  <code>class-attribute</code>","text":"<p>The id of the class or key-point to annotate</p>"},{"location":"package/rerun/__init__/#rerun.log.annotation.AnnotationInfo.label","title":"<code>label: Optional[str] = None</code>  <code>class-attribute</code>","text":"<p>The label that will be shown in the UI</p>"},{"location":"package/rerun/__init__/#rerun.log.annotation.AnnotationInfo.color","title":"<code>color: Optional[Color] = None</code>  <code>class-attribute</code>","text":"<p>The color that will be applied to the annotated entity</p>"},{"location":"package/rerun/__init__/#rerun.LogLevel","title":"<code>class LogLevel</code>  <code>dataclass</code>","text":"<p>Represents the standard log levels.</p> <p>This is a collection of constants rather than an enum because we do support arbitrary strings as level (e.g. for user-defined levels).</p>"},{"location":"package/rerun/__init__/#rerun.log.text_internal.LogLevel.CRITICAL","title":"<code>CRITICAL: Final = 'CRITICAL'</code>  <code>class-attribute</code>","text":"<p>Designates catastrophic failures.</p>"},{"location":"package/rerun/__init__/#rerun.log.text_internal.LogLevel.ERROR","title":"<code>ERROR: Final = 'ERROR'</code>  <code>class-attribute</code>","text":"<p>Designates very serious errors.</p>"},{"location":"package/rerun/__init__/#rerun.log.text_internal.LogLevel.WARN","title":"<code>WARN: Final = 'WARN'</code>  <code>class-attribute</code>","text":"<p>Designates hazardous situations.</p>"},{"location":"package/rerun/__init__/#rerun.log.text_internal.LogLevel.INFO","title":"<code>INFO: Final = 'INFO'</code>  <code>class-attribute</code>","text":"<p>Designates useful information.</p>"},{"location":"package/rerun/__init__/#rerun.log.text_internal.LogLevel.DEBUG","title":"<code>DEBUG: Final = 'DEBUG'</code>  <code>class-attribute</code>","text":"<p>Designates lower priority information.</p>"},{"location":"package/rerun/__init__/#rerun.log.text_internal.LogLevel.TRACE","title":"<code>TRACE: Final = 'TRACE'</code>  <code>class-attribute</code>","text":"<p>Designates very low priority, often extremely verbose, information.</p>"},{"location":"package/rerun/__init__/#rerun.MeshFormat","title":"<code>class MeshFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Mesh file format.</p>"},{"location":"package/rerun/__init__/#rerun.log.file.MeshFormat.GLB","title":"<code>GLB = 'GLB'</code>  <code>class-attribute</code>","text":"<p>glTF binary format.</p>"},{"location":"package/rerun/__init__/#rerun.log.file.MeshFormat.OBJ","title":"<code>OBJ = 'OBJ'</code>  <code>class-attribute</code>","text":"<p>Wavefront .obj format.</p>"},{"location":"package/rerun/__init__/#rerun.LoggingHandler","title":"<code>class LoggingHandler(root_entity_path=None)</code>","text":"<p>         Bases: <code>logging.Handler</code></p> <p>Provides a logging handler that forwards all events to the Rerun SDK.</p> <p>Because Rerun's data model doesn't match 1-to-1 with the different concepts from python's logging ecosystem, we need a way to map the latter to the former:</p>"},{"location":"package/rerun/__init__/#rerun.LoggingHandler--mapping","title":"Mapping","text":"<ul> <li> <p>Root Entity: Optional root entity to gather all the logs under.</p> </li> <li> <p>Entity path: the name of the logger responsible for the creation of the LogRecord                is used as the final entity path, appended after the Root Entity path.</p> </li> <li> <p>Level: the log level is mapped as-is.</p> </li> <li> <p>Body: the body of the text entry corresponds to the formatted output of         the LogRecord using the standard formatter of the logging package,         unless it has been overridden by the user.</p> </li> </ul> <p>Read more about logging handlers</p>"},{"location":"package/rerun/__init__/#rerun.log.text.LoggingHandler.emit","title":"<code>def emit(record)</code>","text":"<p>Emits a record to the Rerun SDK.</p>"},{"location":"package/rerun/__init__/#rerun.RectFormat","title":"<code>class RectFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>How to specify rectangles (axis-aligned bounding boxes).</p>"},{"location":"package/rerun/__init__/#rerun.components.rect2d.RectFormat.XYWH","title":"<code>XYWH = 'XYWH'</code>  <code>class-attribute</code>","text":"<p>[x,y,w,h], with x,y = left,top.</p>"},{"location":"package/rerun/__init__/#rerun.components.rect2d.RectFormat.YXHW","title":"<code>YXHW = 'YXHW'</code>  <code>class-attribute</code>","text":"<p>[y,x,h,w], with x,y = left,top.</p>"},{"location":"package/rerun/__init__/#rerun.components.rect2d.RectFormat.XYXY","title":"<code>XYXY = 'XYXY'</code>  <code>class-attribute</code>","text":"<p>[x0, y0, x1, y1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/__init__/#rerun.components.rect2d.RectFormat.YXYX","title":"<code>YXYX = 'YXYX'</code>  <code>class-attribute</code>","text":"<p>[y0, x0, y1, x1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/__init__/#rerun.components.rect2d.RectFormat.XCYCWH","title":"<code>XCYCWH = 'XCYCWH'</code>  <code>class-attribute</code>","text":"<p>[x_center, y_center, width, height].</p>"},{"location":"package/rerun/__init__/#rerun.components.rect2d.RectFormat.XCYCW2H2","title":"<code>XCYCW2H2 = 'XCYCW2H2'</code>  <code>class-attribute</code>","text":"<p>[x_center, y_center, width/2, height/2].</p>"},{"location":"package/rerun/__init__/#rerun.ImageFormat","title":"<code>class ImageFormat</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Image file format.</p>"},{"location":"package/rerun/__init__/#rerun.log.file.ImageFormat.JPEG","title":"<code>JPEG = 'jpeg'</code>  <code>class-attribute</code>","text":"<p>JPEG format.</p>"},{"location":"package/rerun/__init__/#rerun.ClassDescription","title":"<code>class ClassDescription</code>  <code>dataclass</code>","text":"<p>Metadata about a class type identified by an id.</p> <p>Typically a class description contains only a annotation info. However, within a class there might be several keypoints, each with its own annotation info. Keypoints in turn may be connected to each other by connections (typically used for skeleton edges).</p>"},{"location":"package/rerun/__init__/#rerun.log.annotation.ClassDescription.info","title":"<code>info: Optional[AnnotationInfoLike] = None</code>  <code>class-attribute</code>","text":"<p>The annotation info for the class</p>"},{"location":"package/rerun/__init__/#rerun.log.annotation.ClassDescription.keypoint_annotations","title":"<code>keypoint_annotations: Optional[Iterable[AnnotationInfoLike]] = None</code>  <code>class-attribute</code>","text":"<p>The annotation infos for the all key-points</p>"},{"location":"package/rerun/__init__/#rerun.log.annotation.ClassDescription.keypoint_connections","title":"<code>keypoint_connections: Optional[Iterable[Union[int, Tuple[int, int]]]] = None</code>  <code>class-attribute</code>","text":"<p>The connections between key-points</p>"},{"location":"package/rerun/__init__/#rerun.log_imu","title":"<code>def log_imu(accel, gyro, orientation, mag=None)</code>","text":"<p>Log an IMU sensor reading.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <p>Path to the IMU sensor in the space hierarchy.</p> required <code>accel</code> <code>npt.ArrayLike</code> <p>Acceleration vector in m/s^2.</p> required <code>gyro</code> <code>npt.ArrayLike</code> <p>Angular velocity vector in rad/s.</p> required <code>orientation</code> <code>npt.ArrayLike</code> <p>Orientation quaternion.</p> required <code>mag</code> <code>Union[npt.ArrayLike, None]</code> <p>Magnetometer vector in uT.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_pinhole","title":"<code>def log_pinhole(entity_path, *, child_from_parent, width, height, timeless=False)</code>","text":"<p>Log a perspective camera model.</p> <p>This logs the pinhole model that projects points from the parent (camera) space to this space (image) such that: <pre><code>point_image_hom = child_from_parent * point_cam\npoint_image = point_image_hom[:,1] / point_image_hom[2]\n</code></pre></p> <p>Where <code>point_image_hom</code> is the projected point in the image space expressed in homogeneous coordinates.</p>"},{"location":"package/rerun/__init__/#rerun.log_pinhole--example","title":"Example","text":"<pre><code>width = 640\nheight = 480\nu_cen = width / 2\nv_cen = height / 2\nf_len = (height * width) ** 0.5\n\nrerun.log_pinhole(\"world/camera/image\",\n                  child_from_parent = [[f_len, 0,     u_cen],\n                                       [0,     f_len, v_cen],\n                                       [0,     0,     1  ]],\n                  width = width,\n                  height = height)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the child (image) space in the space hierarchy.</p> required <code>child_from_parent</code> <code>npt.ArrayLike</code> <p>Row-major intrinsics matrix for projecting from camera space to image space.</p> required <code>width</code> <code>int</code> <p>Width of the image in pixels.</p> required <code>height</code> <code>int</code> <p>Height of the image in pixels.</p> required <code>timeless</code> <code>bool</code> <p>If true, the camera will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_image","title":"<code>def log_image(entity_path, image, *, ext=None, timeless=False)</code>","text":"<p>Log a gray or color image.</p> <p>The image should either have 1, 3 or 4 channels (gray, RGB or RGBA).</p>"},{"location":"package/rerun/__init__/#rerun.log_image--supported-dtypes","title":"Supported dtypes","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>uint16: color components should be in 0-65535 sRGB gamma space, except for alpha which should be in 0-65535 linear space.</li> <li>float32, float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the image to log.</p> required <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_mesh","title":"<code>def log_mesh(entity_path, positions, *, indices=None, normals=None, albedo_factor=None, vertex_colors=None, timeless=False)</code>","text":"<p>Log a raw 3D mesh by specifying its vertex positions, and optionally indices, normals and albedo factor.</p> <p>You can also use [<code>rerun.log_mesh_file</code>] to log .gltf, .glb, .obj, etc.</p>"},{"location":"package/rerun/__init__/#rerun.log_mesh--example","title":"Example:","text":"<pre><code># A simple red triangle:\nrerun.log_mesh(\n    \"world/mesh\",\n    positions = [\n        [0.0, 0.0, 0.0],\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0]\n    ],\n    indices = [0, 1, 2],\n    normals = [\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, 1.0]\n    ],\n    albedo_factor = [1.0, 0.0, 0.0],\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>positions</code> <code>Any</code> <p>An array of 3D points. If no <code>indices</code> are specified, then each triplet of positions is interpreted as a triangle.</p> required <code>indices</code> <code>Optional[Any]</code> <p>If specified, is a flattened array of indices that describe the mesh's triangles, i.e. its length must be divisible by 3.</p> <code>None</code> <code>normals</code> <code>Optional[Any]</code> <p>If specified, is a (potentially flattened) array of 3D vectors that describe the normal for each vertex, i.e. the total number of elements must be divisible by 3 and more importantly, <code>len(normals)</code> should be equal to <code>len(positions)</code>.</p> <code>None</code> <code>albedo_factor</code> <code>Optional[Any]</code> <p>Optional color multiplier of the mesh using RGB or unmuliplied RGBA in linear 0-1 space.</p> <code>None</code> <code>vertex_colors</code> <code>Optional[Colors]</code> <p>Optional array of RGB(A) vertex colors, in sRGB gamma space, either as 0-1 floats or 0-255 integers. If specified, the alpha is considered separate (unmultiplied).</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_scalar","title":"<code>def log_scalar(entity_path, scalar, *, label=None, color=None, radius=None, scattered=None, ext=None)</code>","text":"<p>Log a double-precision scalar that will be visualized as a timeseries plot.</p> <p>The current simulation time will be used for the time/X-axis, hence scalars cannot be timeless!</p> <p>See here for a larger example.</p>"},{"location":"package/rerun/__init__/#rerun.log_scalar--understanding-the-plot-and-attributes-hierarchy","title":"Understanding the plot and attributes hierarchy","text":"<p>Timeseries come in three parts: points, lines and finally the plots themselves. As a user of the Rerun SDK, your one and only entrypoint into that hierarchy is through the lowest-level layer: the points.</p> <p>When logging scalars and their attributes (label, color, radius, scattered) through this function, Rerun will turn them into points with similar attributes. From these points, lines with appropriate attributes can then be inferred; and from these inferred lines, plots with appropriate attributes will be inferred in turn!</p> <p>In terms of actual hierarchy:</p> <ul> <li>Each space represents a single plot.</li> <li>Each entity path within a space that contains scalar data is a line within that plot.</li> <li>Each logged scalar is a point.</li> </ul> <p>E.g. the following: <pre><code>t=1.0\nrerun.log_scalar(\"trig/sin\", math.sin(t), label=\"sin(t)\", color=[255, 0, 0])\nrerun.log_scalar(\"trig/cos\", math.cos(t), label=\"cos(t)\", color=[0, 0, 255])\n</code></pre> will yield a single plot (space = <code>trig</code>), comprised of two lines (entity paths <code>trig/sin</code> and <code>trig/cos</code>).</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the scalar in the space hierarchy.</p> required <code>scalar</code> <code>float</code> <p>The scalar value to log.</p> required <code>label</code> <code>Optional[str]</code> <p>An optional label for the point.</p> <p>This won't show up on points at the moment, as our plots don't yet support displaying labels for individual points TODO(https://github.com/rerun-io/rerun/issues/1289). If all points within a single entity path (i.e. a line) share the same label, then this label will be used as the label for the line itself. Otherwise, the line will be named after the entity path. The plot itself is named after the space it's in.</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <p>If left unspecified, a pseudo-random color will be used instead. That same color will apply to all points residing in the same entity path that don't have a color specified.</p> <p>Points within a single line do not have to share the same color, the line will have differently colored segments as appropriate. If all points within a single entity path (i.e. a line) share the same color, then this color will be used as the line color in the plot legend. Otherwise, the line will appear grey in the legend.</p> <code>None</code> <code>radius</code> <code>Optional[float]</code> <p>An optional radius for the point.</p> <p>Points within a single line do not have to share the same radius, the line will have differently sized segments as appropriate.</p> <p>If all points within a single entity path (i.e. a line) share the same radius, then this radius will be used as the line width too. Otherwise, the line will use the default width of <code>1.0</code>.</p> <code>None</code> <code>scattered</code> <code>Optional[bool]</code> <p>Specifies whether the point should form a continuous line with its neighbors, or whether it should stand on its own, akin to a scatter plot. Points within a single line do not have to all share the same scatteredness: the line will switch between a scattered and a continuous representation as required.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_arrow","title":"<code>def log_arrow(entity_path, origin, vector=None, *, color=None, label=None, width_scale=None, ext=None, timeless=False)</code>","text":"<p>Log a 3D arrow.</p> <p>An arrow is defined with an <code>origin</code>, and a <code>vector</code>. This can also be considered as <code>start</code> and <code>end</code> positions for the arrow.</p> <p>The shaft is rendered as a cylinder with <code>radius = 0.5 * width_scale</code>. The tip is rendered as a cone with <code>height = 2.0 * width_scale</code> and <code>radius = 1.0 * width_scale</code>.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to store the entity at.</p> required <code>origin</code> <code>Optional[npt.ArrayLike]</code> <p>The base position of the arrow.</p> required <code>vector</code> <code>Optional[npt.ArrayLike]</code> <p>The vector along which the arrow will be drawn.</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>An optional text to show beside the arrow.</p> <code>None</code> <code>width_scale</code> <code>Optional[float]</code> <p>An optional scaling factor, default=1.0.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>The entity is not time-dependent, and will be visible at any time point.</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_view_coordinates","title":"<code>def log_view_coordinates(entity_path, *, xyz='', up='', right_handed=None, timeless=False)</code>","text":"<p>Log the view coordinates for an entity.</p> <p>Each entity defines its own coordinate system, called a space. By logging view coordinates you can give semantic meaning to the XYZ axes of the space. This is for example useful for camera entities (\"what axis is forward?\").</p> <p>For full control, set the <code>xyz</code> parameter to a three-letter acronym (<code>xyz=\"RDF\"</code>). Each letter represents:</p> <ul> <li>R: Right</li> <li>L: Left</li> <li>U: Up</li> <li>D: Down</li> <li>F: Forward</li> <li>B: Back</li> </ul> <p>Some of the most common are:</p> <ul> <li>\"RDF\": X=Right Y=Down Z=Forward  (right-handed)</li> <li>\"RUB\"  X=Right Y=Up   Z=Back     (right-handed)</li> <li>\"RDB\": X=Right Y=Down Z=Back     (left-handed)</li> <li>\"RUF\": X=Right Y=Up   Z=Forward  (left-handed)</li> </ul>"},{"location":"package/rerun/__init__/#rerun.log_view_coordinates--example","title":"Example","text":"<pre><code>rerun.log_view_coordinates(\"world/camera\", xyz=\"RUB\")\n</code></pre> <p>For world-coordinates it's often convenient to just specify an up-axis. You can do so by using the <code>up</code>-parameter (where <code>up</code> is one of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\"):</p> <pre><code>rerun.log_view_coordinates(\"world\", up=\"+Z\", right_handed=True, timeless=True)\nrerun.log_view_coordinates(\"world\", up=\"-Y\", right_handed=False, timeless=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path in the space hierarchy where the view coordinate will be set.</p> required <code>xyz</code> <code>str</code> <p>Three-letter acronym for the view coordinate axes.</p> <code>''</code> <code>up</code> <code>str</code> <p>Which axis is up? One of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\".</p> <code>''</code> <code>right_handed</code> <code>Optional[bool]</code> <p>If True, the coordinate system is right-handed. If False, it is left-handed.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the view coordinates will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_obb","title":"<code>def log_obb(entity_path, *, half_size, position=None, rotation_q=None, color=None, stroke_width=None, label=None, class_id=None, ext=None, timeless=False)</code>","text":"<p>Log a 3D Oriented Bounding Box, or OBB.</p>"},{"location":"package/rerun/__init__/#rerun.log_obb--example","title":"Example:","text":"<pre><code>rr.log_obb(\"my_obb\", half_size=[1.0, 2.0, 3.0], position=[0, 0, 0], rotation_q=[0, 0, 0, 1])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the oriented bounding box in the space hierarchy.</p> required <code>half_size</code> <code>Optional[npt.ArrayLike]</code> <p>Array with [x, y, z] half dimensions of the OBB.</p> required <code>position</code> <code>Optional[npt.ArrayLike]</code> <p>Optional array with [x, y, z] position of the OBB in world space.</p> <code>None</code> <code>rotation_q</code> <code>Optional[npt.ArrayLike]</code> <p>Optional array with quaternion coordinates [x, y, z, w] for the rotation from model to world space.</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>stroke_width</code> <code>Optional[float]</code> <p>Optional width of the line edges.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text label placed at <code>position</code>.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the OBB.  The class id provides colors and labels if not specified explicitly.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the bounding box will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.script_add_args","title":"<code>def script_add_args(parser)</code>","text":"<p>Add common Rerun script arguments to <code>parser</code>.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The parser to add arguments to.</p> required"},{"location":"package/rerun/__init__/#rerun.log_rect","title":"<code>def log_rect(entity_path, rect, *, rect_format=RectFormat.XYWH, color=None, label=None, class_id=None, ext=None, timeless=False)</code>","text":"<p>Log a 2D rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangle in the space hierarchy.</p> required <code>rect</code> <code>Optional[npt.ArrayLike]</code> <p>the rectangle in [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text to show inside the rectangle.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the rectangle. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the rect will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_point","title":"<code>def log_point(entity_path, position=None, *, radius=None, color=None, label=None, class_id=None, keypoint_id=None, ext=None, timeless=False)</code>","text":"<p>Log a 2D or 3D point, with a position and optional color, radii, label, etc.</p> <p>Logging again to the same <code>entity_path</code> will replace the previous point.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA represented as a 2-element or 3-element sequence.</p>"},{"location":"package/rerun/__init__/#rerun.log_point--supported-dtypes-for-color","title":"Supported dtypes for <code>color</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the point in the space hierarchy.</p> required <code>position</code> <code>Optional[npt.ArrayLike]</code> <p>Any 2-element or 3-element array-like.</p> <code>None</code> <code>radius</code> <code>Optional[float]</code> <p>Optional radius (make it a sphere).</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text to show with the point.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the point. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_id</code> <code>Optional[int]</code> <p>Optional key point id for the point, identifying it within a class. If keypoint_id is passed but no class_id was specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the point will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_line_strip","title":"<code>def log_line_strip(entity_path, positions, *, stroke_width=None, color=None, ext=None, timeless=False)</code>","text":"<p>Log a line strip through 2D or 3D space.</p> <p>A line strip is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so: <pre><code>       2------3     5\n      /        \\   /\n0----1          \\ /\n                 4\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the path in the space hierarchy</p> required <code>positions</code> <code>Optional[npt.ArrayLike]</code> <p>An Nx2 or Nx3 array of points along the path.</p> required <code>stroke_width</code> <code>Optional[float]</code> <p>Optional width of the line.</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the path will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_tensor","title":"<code>def log_tensor(entity_path, tensor, *, names=None, meter=None, ext=None, timeless=False)</code>","text":"<p>Log an n-dimensional tensor.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the tensor in the space hierarchy.</p> required <code>tensor</code> <code>npt.ArrayLike</code> <p>A Tensor object.</p> required <code>names</code> <code>Optional[Iterable[Optional[str]]]</code> <p>Optional names for each dimension of the tensor.</p> <code>None</code> <code>meter</code> <code>Optional[float]</code> <p>Optional scale of the tensor (e.g. meters per cell).</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the tensor will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_mesh_file","title":"<code>def log_mesh_file(entity_path, mesh_format, mesh_file, *, transform=None, timeless=False)</code>","text":"<p>Log the contents of a mesh file (.gltf, .glb, .obj, \u2026).</p> <p>You can also use [<code>rerun.log_mesh</code>] to log raw mesh data.</p>"},{"location":"package/rerun/__init__/#rerun.log_mesh_file--example","title":"Example:","text":"<pre><code># Move mesh 10 units along the X axis.\ntransform=np.array([\n    [1, 0, 0, 10],\n    [0, 1, 0, 0],\n    [0, 0, 1, 0]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>mesh_format</code> <code>MeshFormat</code> <p>Format of the mesh file</p> required <code>mesh_file</code> <code>bytes</code> <p>Contents of the mesh file</p> required <code>transform</code> <code>Optional[npt.ArrayLike]</code> <p>Optional 3x4 affine transform matrix applied to the mesh</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.script_setup","title":"<code>def script_setup(args, application_id)</code>","text":"<p>Run common Rerun script setup actions. Connect to the viewer if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>The parsed arguments from <code>parser.parse_args()</code>.</p> required <code>application_id</code> <code>str</code> <p>The application ID to use for the viewer.</p> required"},{"location":"package/rerun/__init__/#rerun.log_extension_components","title":"<code>def log_extension_components(entity_path, ext, *, identifiers=None, timeless=False)</code>","text":"<p>Log an arbitrary collection of extension components.</p> <p>Each item in <code>ext</code> will be logged as a separate component.</p> <ul> <li>The key will be used as the name of the component</li> <li>The value must be able to be converted to an array of arrow types. In general, if    you can pass it to pyarrow.array,    you can log it as a extension component.</li> </ul> <p>All values must either have the same length, or be singular in which case they will be treated as a splat.</p> <p>Extension components will be prefixed with \"ext.\" to avoid collisions with rerun native components. You do not need to include this prefix; it will be added for you.</p> <p>Note: rerun requires that a given component only take on a single type. The first type logged will be the type that is used for all future logs of that component. The API will make a best effort to do type conversion if supported by numpy and arrow. Any components that can't be converted will be dropped.</p> <p>If you are want to inspect how your component will be converted to the underlying arrow code, the following snippet is what is happening internally: <pre><code>np_value = np.atleast_1d(np.array(value, copy=False))\npa_value = pa.array(value)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the extension components in the space hierarchy.</p> required <code>ext</code> <code>Dict[str, Any]</code> <p>A dictionary of extension components.</p> required <code>identifiers</code> <code>Optional[Sequence[int]]</code> <p>Optional identifiers for each component. If provided, must be the same length as the components.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the components will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_text_entry","title":"<code>def log_text_entry(entity_path, text, *, level=LogLevel.INFO, color=None, ext=None, timeless=False)</code>","text":"<p>Log a text entry, with optional level.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The object path to log the text entry under.</p> required <code>text</code> <code>str</code> <p>The text to log.</p> required <code>level</code> <code>Optional[str]</code> <p>The level of the text entry (default: <code>LogLevel.INFO</code>). Note this can technically be an arbitrary string, but it's recommended to use one of the constants from LogLevel</p> <code>LogLevel.INFO</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>Whether the text entry should be timeless.</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_annotation_context","title":"<code>def log_annotation_context(entity_path, class_descriptions, *, timeless=True)</code>","text":"<p>Log an annotation context made up of a collection of ClassDescriptions.</p> <p>Any entity needing to access the annotation context will find it by searching the path upward. If all entities share the same you can simply log it to the root (\"/\"), or if you want a per-entity ClassDescriptions log it to the same path as your entity.</p> <p>Each ClassDescription must include an annotation info with an id, which will be used for matching the class and may optionally include a label and color. Colors should either be in 0-255 gamma space or in 0-1 gamma space. Colors can be RGB or RGBA.</p> <p>These can either be specified verbosely as: <pre><code>[AnnotationInfo(id=23, label='foo', color=(255, 0, 0)), ...]\n</code></pre></p> <p>Or using short-hand tuples. <pre><code>[(23, 'bar'), ...]\n</code></pre></p> <p>Unspecified colors will be filled in by the visualizer randomly.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the annotation context in the space hierarchy.</p> required <code>class_descriptions</code> <code>Union[ClassDescriptionLike, Iterable[ClassDescriptionLike]]</code> <p>A single ClassDescription or a collection of ClassDescriptions.</p> required <code>timeless</code> <code>bool</code> <p>If true, the annotation context will be timeless (default: True).</p> <code>True</code>"},{"location":"package/rerun/__init__/#rerun.log_depth_image","title":"<code>def log_depth_image(entity_path, image, *, meter=None, ext=None, timeless=False)</code>","text":"<p>Log a depth image.</p> <p>The image must be a 2D array.</p>"},{"location":"package/rerun/__init__/#rerun.log_depth_image--supported-dtypes","title":"Supported dtypes","text":"<p>uint8, uint16, float32, float64</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the depth image to log.</p> required <code>meter</code> <code>Optional[float]</code> <p>How long is a meter in the given dtype? For instance: with uint16, perhaps meter=1000 which would mean you have millimeter precision and a range of up to ~65 meters (2^16 / 1000).</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.script_teardown","title":"<code>def script_teardown(args)</code>","text":"<p>Run common post-actions. Sleep if serving the web viewer.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>The parsed arguments from <code>parser.parse_args()</code>.</p> required"},{"location":"package/rerun/__init__/#rerun.log_cleared","title":"<code>def log_cleared(entity_path, *, recursive=False)</code>","text":"<p>Indicate that an entity at a given path should no longer be displayed.</p> <p>If <code>recursive</code> is True this will also clear all sub-paths</p>"},{"location":"package/rerun/__init__/#rerun.log_image_file","title":"<code>def log_image_file(entity_path, *, img_bytes=None, img_path=None, img_format=None, timeless=False)</code>","text":"<p>Log an image file given its contents or path on disk.</p> <p>Only JPEGs are supported right now.</p> <p>You must pass either <code>img_bytes</code> or <code>img_path</code>.</p> <p>If no <code>img_format</code> is specified, we will try and guess it.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>img_bytes</code> <code>Optional[bytes]</code> <p>Content of an image file, e.g. a <code>.jpg</code>.</p> <code>None</code> <code>img_path</code> <code>Optional[Path]</code> <p>Path to an image file, e.g. a <code>.jpg</code>.</p> <code>None</code> <code>img_format</code> <code>Optional[ImageFormat]</code> <p>Format of the image file.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.get_recording_id","title":"<code>def get_recording_id()</code>","text":"<p>Get the recording ID that this process is logging to, as a UUIDv4.</p> <p>The default recording_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default recording_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same recording), you will need to manually assign them all the same recording_id. Any random UUIDv4 will work, or copy the recording id for the parent process.</p> <p>Returns:</p> Type Description <code>str</code> <p>The recording ID that this process is logging to.</p>"},{"location":"package/rerun/__init__/#rerun.log_unknown_transform","title":"<code>def log_unknown_transform(entity_path, timeless=False)</code>","text":"<p>Log that this entity is NOT in the same space as the parent, but you do not (yet) know how they relate.</p>"},{"location":"package/rerun/__init__/#rerun.log_meshes","title":"<code>def log_meshes(entity_path, position_buffers, *, vertex_color_buffers, index_buffers, normal_buffers, albedo_factors, timeless=False)</code>","text":"<p>Log multiple raw 3D meshes by specifying their different buffers and albedo factors.</p> <p>To learn more about how the data within these buffers is interpreted and laid out, refer to the documentation for [<code>rerun.log_mesh</code>].</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>position_buffers</code> <code>Sequence[npt.ArrayLike]</code> <p>A sequence of position buffers, one for each mesh.</p> required <code>vertex_color_buffers</code> <code>Sequence[Optional[Colors]]</code> <p>An optional sequence of vertex color buffers, one for each mesh.</p> required <code>index_buffers</code> <code>Sequence[Optional[npt.ArrayLike]]</code> <p>An optional sequence of index buffers, one for each mesh.</p> required <code>normal_buffers</code> <code>Sequence[Optional[npt.ArrayLike]]</code> <p>An optional sequence of normal buffers, one for each mesh.</p> required <code>albedo_factors</code> <code>Sequence[Optional[npt.ArrayLike]]</code> <p>An optional sequence of albedo factors, one for each mesh.</p> required <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_rects","title":"<code>def log_rects(entity_path, rects, *, rect_format=RectFormat.XYWH, identifiers=None, colors=None, labels=None, class_ids=None, ext=None, timeless=False)</code>","text":"<p>Log multiple 2D rectangles.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous rectangles.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"package/rerun/__init__/#rerun.log_rects--supported-dtypes-for-colors","title":"Supported <code>dtype</code>s for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangles in the space hierarchy.</p> required <code>rects</code> <code>Optional[npt.ArrayLike]</code> <p>Nx4 numpy array, where each row is [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>identifiers</code> <code>Optional[Sequence[int]]</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Optional[Union[Color, Colors]]</code> <p>Optional per-rectangle gamma-space RGB or RGBA as 0-1 floats or 0-255 integers.</p> <code>None</code> <code>labels</code> <code>Optional[Sequence[str]]</code> <p>Optional per-rectangle text to show inside the rectangle.</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the rectangles. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the rects will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_rigid3","title":"<code>def log_rigid3(entity_path, *, parent_from_child=None, child_from_parent=None, xyz='', timeless=False)</code>","text":"<p>Log a proper rigid 3D transform between this entity and the parent.</p> <p>Set either <code>parent_from_child</code> or <code>child_from_parent</code> to a tuple of <code>(translation_xyz, quat_xyzw)</code>.</p>"},{"location":"package/rerun/__init__/#rerun.log_rigid3--parent-from-child","title":"Parent-from-child","text":"<p>Also known as pose (e.g. camera extrinsics).</p> <p>The translation is the position of the entity in the parent space. The resulting transform from child to parent corresponds to taking a point in the child space, rotating it by the given rotations, and then translating it by the given translation:</p> <p><code>point_parent = translation + quat * point_child * quat*</code></p>"},{"location":"package/rerun/__init__/#rerun.log_rigid3--example","title":"Example","text":"<pre><code>t = 0.0\ntranslation = [math.sin(t), math.cos(t), 0.0] # circle around origin\nrotation = [0.5, 0.0, 0.0, np.sin(np.pi/3)] # 60 degrees around x-axis\nrerun.log_rigid3(\"sun/planet\", parent_from_child=(translation, rotation))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path of the child space in the space hierarchy.</p> required <code>parent_from_child</code> <code>Optional[Tuple[npt.ArrayLike, npt.ArrayLike]]</code> <p>A tuple of <code>(translation_xyz, quat_xyzw)</code> mapping points in the child space to the parent space.</p> <code>None</code> <code>child_from_parent</code> <code>Optional[Tuple[npt.ArrayLike, npt.ArrayLike]]</code> <p>the inverse of <code>parent_from_child</code></p> <code>None</code> <code>xyz</code> <code>str</code> <p>Optionally set the view coordinates of this entity, e.g. to <code>RDF</code> for <code>X=Right, Y=Down, Z=Forward</code>. This is a convenience for also calling log_view_coordinates.</p> <code>''</code> <code>timeless</code> <code>bool</code> <p>If true, the transform will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_line_segments","title":"<code>def log_line_segments(entity_path, positions, *, stroke_width=None, color=None, ext=None, timeless=False)</code>","text":"<p>Log many 2D or 3D line segments.</p> <p>The points will be connected in even-odd pairs, like so:</p> <pre><code>       2------3     5\n                   /\n0----1            /\n                 4\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the line segments in the space hierarchy</p> required <code>positions</code> <code>npt.ArrayLike</code> <p>An Nx2 or Nx3 array of points. Even-odd pairs will be connected as segments.</p> required <code>stroke_width</code> <code>Optional[float]</code> <p>Optional width of the line.</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the line segments will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.set_recording_id","title":"<code>def set_recording_id(value)</code>","text":"<p>Set the recording ID that this process is logging to, as a UUIDv4.</p> <p>The default recording_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default recording_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same recording), you will need to manually assign them all the same recording_id. Any random UUIDv4 will work, or copy the recording id for the parent process.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The recording ID to use for this process.</p> required"},{"location":"package/rerun/__init__/#rerun.log_points","title":"<code>def log_points(entity_path, positions=None, *, identifiers=None, colors=None, radii=None, labels=None, class_ids=None, keypoint_ids=None, ext=None, timeless=False)</code>","text":"<p>Log 2D or 3D points, with positions and optional colors, radii, labels, etc.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous points.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"package/rerun/__init__/#rerun.log_points--supported-dtypes-for-colors","title":"Supported dtypes for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the points in the space hierarchy.</p> required <code>positions</code> <code>Optional[npt.ArrayLike]</code> <p>Nx2 or Nx3 array</p> <code>None</code> <code>identifiers</code> <code>Optional[npt.ArrayLike]</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Optional[Union[Color, Colors]]</code> <p>Optional colors of the points. The colors are interpreted as RGB or RGBA in sRGB gamma-space, as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>radii</code> <code>Optional[npt.ArrayLike]</code> <p>Optional radii (make it a sphere).</p> <code>None</code> <code>labels</code> <code>Optional[Sequence[str]]</code> <p>Optional per-point text to show with the points</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the points. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_ids</code> <code>OptionalKeyPointIds</code> <p>Optional key point ids for the points, identifying them within a class. If keypoint_ids are passed in but no class_ids were specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the points will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.init","title":"<code>def init(application_id, spawn=False, default_enabled=True, strict=False)</code>","text":"<p>Initialize the Rerun SDK with a user-chosen application id (name).</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>str</code> <p>Your Rerun recordings will be categorized by this application id, so try to pick a unique one for each application that uses the Rerun SDK.</p> <p>For example, if you have one application doing object detection and another doing camera calibration, you could have <code>rerun.init(\"object_detector\")</code> and <code>rerun.init(\"calibrator\")</code>.</p> required <code>spawn</code> <code>bool</code> <p>Spawn a Depthai Viewer and stream logging data to it. Short for calling <code>spawn</code> separately. If you don't call this, log events will be buffered indefinitely until you call either <code>connect</code>, <code>show</code>, or <code>save</code></p> <code>False</code> <code>default_enabled</code> <code>bool</code> <p>Should Rerun logging be on by default? Can overridden with the RERUN env-var, e.g. <code>RERUN=on</code> or <code>RERUN=off</code>.</p> <code>True</code> <code>strict</code> <code>bool</code> <p>If <code>True</code>, an exceptions is raised on use error (wrong parameter types etc). If <code>False</code>, errors are logged as warnings instead.</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_segmentation_image","title":"<code>def log_segmentation_image(entity_path, image, *, ext=None, timeless=False)</code>","text":"<p>Log an image made up of integer class-ids.</p> <p>The image should have 1 channel, i.e. be either <code>H x W</code> or <code>H x W x 1</code>.</p> <p>See: rerun.log_annotation_context for information on how to map the class-ids to colors and labels.</p>"},{"location":"package/rerun/__init__/#rerun.log_segmentation_image--supported-dtypes","title":"Supported dtypes","text":"<p>uint8, uint16</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>npt.ArrayLike</code> <p>A Tensor representing the segmentation image to log.</p> required <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.is_enabled","title":"<code>def is_enabled()</code>","text":"<p>Is the Rerun SDK enabled.</p> <p>If false, all calls to the rerun library are ignored.</p> <p>The default can be set in <code>rerun.init</code>, but is otherwise <code>True</code>.</p> <p>This can be controlled with the environment variable <code>RERUN</code>, (e.g. <code>RERUN=on</code> or <code>RERUN=off</code>) and with [<code>set_enabled</code>].</p>"},{"location":"package/rerun/__init__/#rerun.set_enabled","title":"<code>def set_enabled(enabled)</code>","text":"<p>Enable or disable logging.</p> <p>If false, all calls to the rerun library are ignored. The default is <code>True</code>.</p> <p>This is a global setting that affects all threads.</p> <p>By default logging is enabled, but can be controlled with the environment variable <code>RERUN</code>, (e.g. <code>RERUN=on</code> or <code>RERUN=off</code>).</p> <p>The default can be set in <code>rerun.init</code>.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>Whether to enable or disable logging.</p> required"},{"location":"package/rerun/__init__/#rerun.strict_mode","title":"<code>def strict_mode()</code>","text":"<p>Strict mode enabled.</p> <p>In strict mode, incorrect use of the Rerun API (wrong parameter types etc.) will result in exception being raised. When strict mode is on, such problems are instead logged as warnings.</p> <p>The default is OFF.</p>"},{"location":"package/rerun/__init__/#rerun.set_strict_mode","title":"<code>def set_strict_mode(strict_mode)</code>","text":"<p>Turn strict mode on/off.</p> <p>In strict mode, incorrect use of the Rerun API (wrong parameter types etc.) will result in exception being raised. When strict mode is off, such problems are instead logged as warnings.</p> <p>The default is OFF.</p>"},{"location":"package/rerun/__init__/#rerun.connect","title":"<code>def connect(addr=None)</code>","text":"<p>Connect to a remote Depthai Viewer on the given ip:port.</p> <p>Requires that you first start a Depthai Viewer, e.g. with 'python -m rerun'</p> <p>This function returns immediately.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>Optional[str]</code> <p>The ip:port to connect to</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.spawn","title":"<code>def spawn(port=9876, connect=True)</code>","text":"<p>Spawn a Depthai Viewer, listening on the given port.</p> <p>This is often the easiest and best way to use Rerun. Just call this once at the start of your program.</p> <p>You can also call rerun.init with a <code>spawn=True</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The port to listen on.</p> <code>9876</code> <code>connect</code> <code>bool</code> <p>also connect to the viewer and stream logging data to it.</p> <code>True</code>"},{"location":"package/rerun/__init__/#rerun.serve","title":"<code>def serve(open_browser=True, web_port=None, ws_port=None)</code>","text":"<p>Serve log-data over WebSockets and serve a Rerun web viewer over HTTP.</p> <p>You can connect to this server using <code>python -m rerun</code>.</p> <p>WARNING: This is an experimental feature.</p> <p>This function returns immediately.</p> <p>Parameters:</p> Name Type Description Default <code>open_browser</code> <code>bool</code> <p>Open the default browser to the viewer.</p> <code>True</code> <code>web_port</code> <code>Optional[int]</code> <p>The port to serve the web viewer on (defaults to 9090).</p> <code>None</code> <code>ws_port</code> <code>Optional[int]</code> <p>The port to serve the WebSocket server on (defaults to 9877)</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.start_web_viewer_server","title":"<code>def start_web_viewer_server(port=0)</code>","text":"<p>Start an HTTP server that hosts the rerun web viewer.</p> <p>This only provides the web-server that makes the viewer available and does not otherwise provide a rerun websocket server or facilitate any routing of data.</p> <p>This is generally only necessary for application such as running a jupyter notebook in a context where app.rerun.io is unavailable, or does not having the matching resources for your build (such as when running from source.)</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to serve assets on. Defaults to 0 (random port).</p> <code>0</code>"},{"location":"package/rerun/__init__/#rerun.disconnect","title":"<code>def disconnect()</code>","text":"<p>Closes all TCP connections, servers, and files.</p> <p>Closes all TCP connections, servers, and files that have been opened with [<code>rerun.connect</code>], [<code>rerun.serve</code>], [<code>rerun.save</code>] or [<code>rerun.spawn</code>].</p>"},{"location":"package/rerun/__init__/#rerun.save","title":"<code>def save(path)</code>","text":"<p>Stream all log-data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the data to.</p> required"},{"location":"package/rerun/__init__/#rerun.memory_recording","title":"<code>def memory_recording()</code>","text":"<p>Streams all log-data to a memory buffer.</p> <p>This can be used to display the RRD to alternative formats such as html. See: rerun.MemoryRecording.as_html.</p> <p>Returns:</p> Type Description <code>MemoryRecording</code> <p>A memory recording object that can be used to read the data.</p>"},{"location":"package/rerun/__init__/#rerun.set_time_sequence","title":"<code>def set_time_sequence(timeline, sequence)</code>","text":"<p>Set the current time for this thread as an integer sequence.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>set_time_sequence</code>.</p> <p>For example: <code>set_time_sequence(\"frame_nr\", frame_nr)</code>.</p> <p>You can remove a timeline again using <code>set_time_sequence(\"frame_nr\", None)</code>.</p> <p>There is no requirement of monotonicity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>sequence</code> <code>int</code> <p>The current time on the timeline in integer units.</p> required"},{"location":"package/rerun/__init__/#rerun.set_time_seconds","title":"<code>def set_time_seconds(timeline, seconds)</code>","text":"<p>Set the current time for this thread in seconds.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>rerun.set_time_seconds</code> or <code>rerun.set_time_nanos</code>.</p> <p>For example: <code>set_time_seconds(\"capture_time\", seconds_since_unix_epoch)</code>.</p> <p>You can remove a timeline again using <code>set_time_seconds(\"capture_time\", None)</code>.</p> <p>Very large values will automatically be interpreted as seconds since unix epoch (1970-01-01). Small values (less than a few years) will be interpreted as relative some unknown point in time, and will be shown as e.g. <code>+3.132s</code>.</p> <p>The bindings has a built-in time which is <code>log_time</code>, and is logged as seconds since unix epoch.</p> <p>There is no requirement of monotonicity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>seconds</code> <code>float</code> <p>The current time on the timeline in seconds.</p> required"},{"location":"package/rerun/__init__/#rerun.set_time_nanos","title":"<code>def set_time_nanos(timeline, nanos)</code>","text":"<p>Set the current time for this thread.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>rerun.set_time_nanos</code> or <code>rerun.set_time_seconds</code>.</p> <p>For example: <code>set_time_nanos(\"capture_time\", nanos_since_unix_epoch)</code>.</p> <p>You can remove a timeline again using <code>set_time_nanos(\"capture_time\", None)</code>.</p> <p>Very large values will automatically be interpreted as nanoseconds since unix epoch (1970-01-01). Small values (less than a few years) will be interpreted as relative some unknown point in time, and will be shown as e.g. <code>+3.132s</code>.</p> <p>The bindings has a built-in time which is <code>log_time</code>, and is logged as nanos since unix epoch.</p> <p>There is no requirement of monotonicity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>nanos</code> <code>int</code> <p>The current time on the timeline in nanoseconds.</p> required"},{"location":"package/rerun/__init__/#rerun.reset_time","title":"<code>def reset_time()</code>","text":"<p>Clear all timeline information on this thread.</p> <p>This is the same as calling <code>set_time_*</code> with <code>None</code> for all of the active timelines.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>rerun.set_time_nanos</code> or <code>rerun.set_time_seconds</code>.</p>"},{"location":"package/rerun/color_conversion/","title":"color_conversion.py","text":""},{"location":"package/rerun/color_conversion/#rerun.color_conversion","title":"<code>rerun.color_conversion</code>","text":"<p>Color conversion utilities.</p>"},{"location":"package/rerun/color_conversion/#rerun.color_conversion.u8_array_to_rgba","title":"<code>def u8_array_to_rgba(arr)</code>","text":"<p>Convert an array with inner dimension [R,G,B,A] into packed uint32 values.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>npt.NDArray[np.uint8]</code> <p>Nx3 or Nx4 <code>[[r,g,b,a], ... ]</code> of uint8 values</p> required <p>Returns:</p> Type Description <code>npt.NDArray[np.uint32]</code> <p>Array of uint32 value as 0xRRGGBBAA.</p>"},{"location":"package/rerun/color_conversion/#rerun.color_conversion.linear_to_gamma_u8_value","title":"<code>def linear_to_gamma_u8_value(linear)</code>","text":"<p>Transform color values from linear [0.0, 1.0] to gamma encoded [0, 255].</p> <p>Linear colors are expected to have dtype numpy.floating</p> <p>Intended to implement the following per color value: <pre><code>if l &lt;= 0.0 {\n0\n} else if l &lt;= 0.0031308 {\nround(3294.6 * l)\n} else if l &lt;= 1.0 {\nround(269.025 * l.powf(1.0 / 2.4) - 14.025)\n} else {\n255\n}\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>linear</code> <code>npt.NDArray[Union[np.float32, np.float64]]</code> <p>The linear color values to transform.</p> required <p>Returns:</p> Type Description <code>np.ndarray[np.uint8]</code> <p>The gamma encoded color values.</p>"},{"location":"package/rerun/color_conversion/#rerun.color_conversion.linear_to_gamma_u8_pixel","title":"<code>def linear_to_gamma_u8_pixel(linear)</code>","text":"<p>Transform color pixels from linear [0, 1] to gamma encoded [0, 255].</p> <p>Linear colors are expected to have dtype np.float32 or np.float64.</p> <p>The last dimension of the colors array <code>linear</code> is expected to represent a single pixel color. - 3 colors means RGB - 4 colors means RGBA</p> <p>Parameters:</p> Name Type Description Default <code>linear</code> <code>npt.NDArray[Union[np.float32, np.float64]]</code> <p>The linear color pixels to transform.</p> required <p>Returns:</p> Type Description <code>np.ndarray[np.uint8]</code> <p>The gamma encoded color pixels.</p>"},{"location":"package/rerun/recording/","title":"recording.py","text":""},{"location":"package/rerun/recording/#rerun.recording","title":"<code>rerun.recording</code>","text":"<p>Helper functions for directly working with recordings.</p>"},{"location":"package/rerun/recording/#rerun.recording.MemoryRecording","title":"<code>class MemoryRecording(storage)</code>","text":""},{"location":"package/rerun/recording/#rerun.recording.MemoryRecording.as_html","title":"<code>def as_html(width=DEFAULT_WIDTH, height=DEFAULT_HEIGHT, app_url=None, timeout_ms=DEFAULT_TIMEOUT)</code>","text":"<p>Generate an HTML snippet that displays the recording in an IFrame.</p> <p>For use in contexts such as Jupyter notebooks.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the viewer in pixels.</p> <code>DEFAULT_WIDTH</code> <code>height</code> <code>int</code> <p>The height of the viewer in pixels.</p> <code>DEFAULT_HEIGHT</code> <code>app_url</code> <code>str</code> <p>Alternative HTTP url to find the Rerun web viewer. This will default to using https://app.rerun.io or localhost if rerun.start_web_viewer_server has been called.</p> <code>None</code> <code>timeout_ms</code> <code>int</code> <p>The number of milliseconds to wait for the Rerun web viewer to load.</p> <code>DEFAULT_TIMEOUT</code>"},{"location":"package/rerun/recording/#rerun.recording.MemoryRecording.show","title":"<code>def show(width=DEFAULT_WIDTH, height=DEFAULT_HEIGHT, app_url=None, timeout_ms=DEFAULT_TIMEOUT)</code>","text":"<p>Output the Rerun viewer using IPython IPython.core.display.HTML.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the viewer in pixels.</p> <code>DEFAULT_WIDTH</code> <code>height</code> <code>int</code> <p>The height of the viewer in pixels.</p> <code>DEFAULT_HEIGHT</code> <code>app_url</code> <code>str</code> <p>Alternative HTTP url to find the Rerun web viewer. This will default to using https://app.rerun.io or localhost if rerun.start_web_viewer_server has been called.</p> <code>None</code> <code>timeout_ms</code> <code>int</code> <p>The number of milliseconds to wait for the Rerun web viewer to load.</p> <code>DEFAULT_TIMEOUT</code>"},{"location":"package/rerun/script_helpers/","title":"script_helpers.py","text":""},{"location":"package/rerun/script_helpers/#rerun.script_helpers","title":"<code>rerun.script_helpers</code>","text":"<p>Helper functions for Rerun scripts.</p> <p>These helper functions can be used to wire up common Rerun features to your script CLi arguments.</p>"},{"location":"package/rerun/script_helpers/#rerun.script_helpers--example","title":"Example","text":"<pre><code>import argparse\nimport rerun as rr\n\nparser = argparse.ArgumentParser()\nrr.script_add_args(parser)\nargs = parser.parse_args()\nrr.script_setup(args, \"my_application\")\n# ... Run your logging code here ...\nrr.script_teardown(args)\n</code></pre>"},{"location":"package/rerun/script_helpers/#rerun.script_helpers.script_add_args","title":"<code>def script_add_args(parser)</code>","text":"<p>Add common Rerun script arguments to <code>parser</code>.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The parser to add arguments to.</p> required"},{"location":"package/rerun/script_helpers/#rerun.script_helpers.script_setup","title":"<code>def script_setup(args, application_id)</code>","text":"<p>Run common Rerun script setup actions. Connect to the viewer if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>The parsed arguments from <code>parser.parse_args()</code>.</p> required <code>application_id</code> <code>str</code> <p>The application ID to use for the viewer.</p> required"},{"location":"package/rerun/script_helpers/#rerun.script_helpers.script_teardown","title":"<code>def script_teardown(args)</code>","text":"<p>Run common post-actions. Sleep if serving the web viewer.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>The parsed arguments from <code>parser.parse_args()</code>.</p> required"},{"location":"package/rerun/components/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/components/__init__/#rerun.components","title":"<code>rerun.components</code>","text":"<p>The components package defines Python wrapper types for common registered Rerun components.</p>"},{"location":"package/rerun/components/__init__/#rerun.components.ComponentTypeFactory","title":"<code>def ComponentTypeFactory(name, array_cls, field)</code>","text":"<p>Build a component type wrapper.</p>"},{"location":"package/rerun/components/__init__/#rerun.components.build_dense_union","title":"<code>def build_dense_union(data_type, discriminant, child)</code>","text":"<p>Build a dense UnionArray given the <code>data_type</code>, a discriminant, and the child value array.</p> <p>If the discriminant string doesn't match any possible value, a <code>ValueError</code> is raised.</p>"},{"location":"package/rerun/components/annotation/","title":"annotation.py","text":""},{"location":"package/rerun/components/annotation/#rerun.components.annotation","title":"<code>rerun.components.annotation</code>","text":""},{"location":"package/rerun/components/annotation/#rerun.components.annotation.ClassIdArray","title":"<code>class ClassIdArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/annotation/#rerun.components.annotation.ClassIdArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>ClassIdArray</code> from an Nx1 numpy array.</p>"},{"location":"package/rerun/components/annotation/#rerun.components.annotation.KeypointIdArray","title":"<code>class KeypointIdArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/annotation/#rerun.components.annotation.KeypointIdArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>KeypointIdArray</code> from an Nx1 numpy array.</p>"},{"location":"package/rerun/components/arrow/","title":"arrow.py","text":""},{"location":"package/rerun/components/arrow/#rerun.components.arrow","title":"<code>rerun.components.arrow</code>","text":""},{"location":"package/rerun/components/arrow/#rerun.components.arrow.Arrow3DArray","title":"<code>class Arrow3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/arrow/#rerun.components.arrow.Arrow3DArray.from_numpy","title":"<code>def from_numpy(origins, vectors)</code>","text":"<p>Build a <code>Arrow3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/components/box/","title":"box.py","text":""},{"location":"package/rerun/components/box/#rerun.components.box","title":"<code>rerun.components.box</code>","text":""},{"location":"package/rerun/components/box/#rerun.components.box.Box3DArray","title":"<code>class Box3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/box/#rerun.components.box.Box3DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Box3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/components/color/","title":"color.py","text":""},{"location":"package/rerun/components/color/#rerun.components.color","title":"<code>rerun.components.color</code>","text":""},{"location":"package/rerun/components/color/#rerun.components.color.ColorRGBAArray","title":"<code>class ColorRGBAArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/color/#rerun.components.color.ColorRGBAArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>ColorRGBAArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/imu/","title":"imu.py","text":""},{"location":"package/rerun/components/imu/#rerun.components.imu","title":"<code>rerun.components.imu</code>","text":""},{"location":"package/rerun/components/imu/#rerun.components.imu.Imu","title":"<code>class Imu</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/imu/#rerun.components.imu.Imu.create","title":"<code>def create(accel, gyro, orientation, mag=None)</code>","text":"<p>Build Imu data from acceleration and gyroscope data.</p>"},{"location":"package/rerun/components/instance/","title":"instance.py","text":""},{"location":"package/rerun/components/instance/#rerun.components.instance","title":"<code>rerun.components.instance</code>","text":""},{"location":"package/rerun/components/instance/#rerun.components.instance.InstanceArray","title":"<code>class InstanceArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/instance/#rerun.components.instance.InstanceArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>InstanceArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/label/","title":"label.py","text":""},{"location":"package/rerun/components/label/#rerun.components.label","title":"<code>rerun.components.label</code>","text":""},{"location":"package/rerun/components/label/#rerun.components.label.LabelArray","title":"<code>class LabelArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/label/#rerun.components.label.LabelArray.new","title":"<code>def new(labels)</code>","text":"<p>Build a <code>LabelArray</code> from a sequence of str.</p>"},{"location":"package/rerun/components/linestrip/","title":"linestrip.py","text":""},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip","title":"<code>rerun.components.linestrip</code>","text":""},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip2DArray","title":"<code>class LineStrip2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip2DArray.from_numpy_arrays","title":"<code>def from_numpy_arrays(array)</code>","text":"<p>Build a <code>LineStrip2DArray</code> from an array of [Nx2 numpy array].</p>"},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip3DArray","title":"<code>class LineStrip3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip3DArray.from_numpy_arrays","title":"<code>def from_numpy_arrays(array)</code>","text":"<p>Build a <code>LineStrip3DArray</code> from an array of [Nx3 numpy array].</p>"},{"location":"package/rerun/components/point/","title":"point.py","text":""},{"location":"package/rerun/components/point/#rerun.components.point","title":"<code>rerun.components.point</code>","text":""},{"location":"package/rerun/components/point/#rerun.components.point.Point2DArray","title":"<code>class Point2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/point/#rerun.components.point.Point2DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Point2DArray</code> from an Nx2 numpy array.</p>"},{"location":"package/rerun/components/point/#rerun.components.point.Point3DArray","title":"<code>class Point3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/point/#rerun.components.point.Point3DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Point3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/components/quaternion/","title":"quaternion.py","text":""},{"location":"package/rerun/components/quaternion/#rerun.components.quaternion","title":"<code>rerun.components.quaternion</code>","text":""},{"location":"package/rerun/components/quaternion/#rerun.components.quaternion.QuaternionArray","title":"<code>class QuaternionArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/quaternion/#rerun.components.quaternion.QuaternionArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>QuaternionArray</code> from an Nx4 numpy array.</p>"},{"location":"package/rerun/components/radius/","title":"radius.py","text":""},{"location":"package/rerun/components/radius/#rerun.components.radius","title":"<code>rerun.components.radius</code>","text":""},{"location":"package/rerun/components/radius/#rerun.components.radius.RadiusArray","title":"<code>class RadiusArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/radius/#rerun.components.radius.RadiusArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>RadiusArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/rect2d/","title":"rect2d.py","text":""},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d","title":"<code>rerun.components.rect2d</code>","text":""},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat","title":"<code>class RectFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>How to specify rectangles (axis-aligned bounding boxes).</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XYWH","title":"<code>XYWH = 'XYWH'</code>  <code>class-attribute</code>","text":"<p>[x,y,w,h], with x,y = left,top.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.YXHW","title":"<code>YXHW = 'YXHW'</code>  <code>class-attribute</code>","text":"<p>[y,x,h,w], with x,y = left,top.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XYXY","title":"<code>XYXY = 'XYXY'</code>  <code>class-attribute</code>","text":"<p>[x0, y0, x1, y1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.YXYX","title":"<code>YXYX = 'YXYX'</code>  <code>class-attribute</code>","text":"<p>[y0, x0, y1, x1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XCYCWH","title":"<code>XCYCWH = 'XCYCWH'</code>  <code>class-attribute</code>","text":"<p>[x_center, y_center, width, height].</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XCYCW2H2","title":"<code>XCYCW2H2 = 'XCYCW2H2'</code>  <code>class-attribute</code>","text":"<p>[x_center, y_center, width/2, height/2].</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.Rect2DArray","title":"<code>class Rect2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.Rect2DArray.from_numpy_and_format","title":"<code>def from_numpy_and_format(array, rect_format)</code>","text":"<p>Build a <code>Rect2DArray</code> from an Nx4 numpy array.</p>"},{"location":"package/rerun/components/scalar/","title":"scalar.py","text":""},{"location":"package/rerun/components/scalar/#rerun.components.scalar","title":"<code>rerun.components.scalar</code>","text":""},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarArray","title":"<code>class ScalarArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>ScalarArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarPlotPropsArray","title":"<code>class ScalarPlotPropsArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarPlotPropsArray.from_props","title":"<code>def from_props(props)</code>","text":"<p>Build a <code>ScalarPlotPropsArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/tensor/","title":"tensor.py","text":""},{"location":"package/rerun/components/tensor/#rerun.components.tensor","title":"<code>rerun.components.tensor</code>","text":""},{"location":"package/rerun/components/tensor/#rerun.components.tensor.TensorArray","title":"<code>class TensorArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/tensor/#rerun.components.tensor.TensorArray.from_numpy","title":"<code>def from_numpy(array, names=None, meaning=None, meter=None)</code>","text":"<p>Build a <code>TensorArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/text_entry/","title":"text_entry.py","text":""},{"location":"package/rerun/components/text_entry/#rerun.components.text_entry","title":"<code>rerun.components.text_entry</code>","text":""},{"location":"package/rerun/components/text_entry/#rerun.components.text_entry.TextEntryArray","title":"<code>class TextEntryArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/text_entry/#rerun.components.text_entry.TextEntryArray.from_bodies_and_levels","title":"<code>def from_bodies_and_levels(text_entries)</code>","text":"<p>Build a <code>TextEntryArray</code> from a sequence of text bodies and log levels.</p> <p>log levels recommended to be one of: * \"CRITICAL\" * \"ERROR\" * \"WARN\" * \"INFO\" * \"DEBUG\" * \"TRACE\"</p>"},{"location":"package/rerun/components/vec/","title":"vec.py","text":""},{"location":"package/rerun/components/vec/#rerun.components.vec","title":"<code>rerun.components.vec</code>","text":""},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec2DArray","title":"<code>class Vec2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec2DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Vec2DArray</code> from an Nx2 numpy array.</p>"},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec3DArray","title":"<code>class Vec3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec3DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Vec3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/log/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/log/__init__/#rerun.log","title":"<code>rerun.log</code>","text":""},{"location":"package/rerun/log/__init__/#rerun.log.log_cleared","title":"<code>def log_cleared(entity_path, *, recursive=False)</code>","text":"<p>Indicate that an entity at a given path should no longer be displayed.</p> <p>If <code>recursive</code> is True this will also clear all sub-paths</p>"},{"location":"package/rerun/log/__init__/#rerun.log.set_visible","title":"<code>def set_visible(entity_path, visible)</code>","text":"<p>set_visible has been deprecated.</p> <p>The replacement is <code>log_cleared()</code>. See: https://github.com/rerun-io/rerun/pull/285 for details</p>"},{"location":"package/rerun/log/annotation/","title":"annotation.py","text":""},{"location":"package/rerun/log/annotation/#rerun.log.annotation","title":"<code>rerun.log.annotation</code>","text":""},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfoLike","title":"<code>AnnotationInfoLike = Union[Tuple[int, str], Tuple[int, str, Color], AnnotationInfo]</code>  <code>module-attribute</code>","text":"<p>Type helper representing the different ways to specify an AnnotationInfo</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescriptionLike","title":"<code>ClassDescriptionLike = Union[AnnotationInfoLike, ClassDescription]</code>  <code>module-attribute</code>","text":"<p>Type helper representing the different ways to specify a ClassDescription</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfo","title":"<code>class AnnotationInfo</code>  <code>dataclass</code>","text":"<p>Annotation info annotating a class id or key-point id.</p> <p>Color and label will be used to annotate entities/keypoints which reference the id. The id refers either to a class or key-point id</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfo.id","title":"<code>id: int = 0</code>  <code>class-attribute</code>","text":"<p>The id of the class or key-point to annotate</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfo.label","title":"<code>label: Optional[str] = None</code>  <code>class-attribute</code>","text":"<p>The label that will be shown in the UI</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfo.color","title":"<code>color: Optional[Color] = None</code>  <code>class-attribute</code>","text":"<p>The color that will be applied to the annotated entity</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescription","title":"<code>class ClassDescription</code>  <code>dataclass</code>","text":"<p>Metadata about a class type identified by an id.</p> <p>Typically a class description contains only a annotation info. However, within a class there might be several keypoints, each with its own annotation info. Keypoints in turn may be connected to each other by connections (typically used for skeleton edges).</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescription.info","title":"<code>info: Optional[AnnotationInfoLike] = None</code>  <code>class-attribute</code>","text":"<p>The annotation info for the class</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescription.keypoint_annotations","title":"<code>keypoint_annotations: Optional[Iterable[AnnotationInfoLike]] = None</code>  <code>class-attribute</code>","text":"<p>The annotation infos for the all key-points</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescription.keypoint_connections","title":"<code>keypoint_connections: Optional[Iterable[Union[int, Tuple[int, int]]]] = None</code>  <code>class-attribute</code>","text":"<p>The connections between key-points</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.log_annotation_context","title":"<code>def log_annotation_context(entity_path, class_descriptions, *, timeless=True)</code>","text":"<p>Log an annotation context made up of a collection of ClassDescriptions.</p> <p>Any entity needing to access the annotation context will find it by searching the path upward. If all entities share the same you can simply log it to the root (\"/\"), or if you want a per-entity ClassDescriptions log it to the same path as your entity.</p> <p>Each ClassDescription must include an annotation info with an id, which will be used for matching the class and may optionally include a label and color. Colors should either be in 0-255 gamma space or in 0-1 gamma space. Colors can be RGB or RGBA.</p> <p>These can either be specified verbosely as: <pre><code>[AnnotationInfo(id=23, label='foo', color=(255, 0, 0)), ...]\n</code></pre></p> <p>Or using short-hand tuples. <pre><code>[(23, 'bar'), ...]\n</code></pre></p> <p>Unspecified colors will be filled in by the visualizer randomly.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the annotation context in the space hierarchy.</p> required <code>class_descriptions</code> <code>Union[ClassDescriptionLike, Iterable[ClassDescriptionLike]]</code> <p>A single ClassDescription or a collection of ClassDescriptions.</p> required <code>timeless</code> <code>bool</code> <p>If true, the annotation context will be timeless (default: True).</p> <code>True</code>"},{"location":"package/rerun/log/arrow/","title":"arrow.py","text":""},{"location":"package/rerun/log/arrow/#rerun.log.arrow","title":"<code>rerun.log.arrow</code>","text":""},{"location":"package/rerun/log/arrow/#rerun.log.arrow.log_arrow","title":"<code>def log_arrow(entity_path, origin, vector=None, *, color=None, label=None, width_scale=None, ext=None, timeless=False)</code>","text":"<p>Log a 3D arrow.</p> <p>An arrow is defined with an <code>origin</code>, and a <code>vector</code>. This can also be considered as <code>start</code> and <code>end</code> positions for the arrow.</p> <p>The shaft is rendered as a cylinder with <code>radius = 0.5 * width_scale</code>. The tip is rendered as a cone with <code>height = 2.0 * width_scale</code> and <code>radius = 1.0 * width_scale</code>.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to store the entity at.</p> required <code>origin</code> <code>Optional[npt.ArrayLike]</code> <p>The base position of the arrow.</p> required <code>vector</code> <code>Optional[npt.ArrayLike]</code> <p>The vector along which the arrow will be drawn.</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>An optional text to show beside the arrow.</p> <code>None</code> <code>width_scale</code> <code>Optional[float]</code> <p>An optional scaling factor, default=1.0.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>The entity is not time-dependent, and will be visible at any time point.</p> <code>False</code>"},{"location":"package/rerun/log/bounding_box/","title":"bounding_box.py","text":""},{"location":"package/rerun/log/bounding_box/#rerun.log.bounding_box","title":"<code>rerun.log.bounding_box</code>","text":""},{"location":"package/rerun/log/bounding_box/#rerun.log.bounding_box.log_obb","title":"<code>def log_obb(entity_path, *, half_size, position=None, rotation_q=None, color=None, stroke_width=None, label=None, class_id=None, ext=None, timeless=False)</code>","text":"<p>Log a 3D Oriented Bounding Box, or OBB.</p>"},{"location":"package/rerun/log/bounding_box/#rerun.log.bounding_box.log_obb--example","title":"Example:","text":"<pre><code>rr.log_obb(\"my_obb\", half_size=[1.0, 2.0, 3.0], position=[0, 0, 0], rotation_q=[0, 0, 0, 1])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the oriented bounding box in the space hierarchy.</p> required <code>half_size</code> <code>Optional[npt.ArrayLike]</code> <p>Array with [x, y, z] half dimensions of the OBB.</p> required <code>position</code> <code>Optional[npt.ArrayLike]</code> <p>Optional array with [x, y, z] position of the OBB in world space.</p> <code>None</code> <code>rotation_q</code> <code>Optional[npt.ArrayLike]</code> <p>Optional array with quaternion coordinates [x, y, z, w] for the rotation from model to world space.</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>stroke_width</code> <code>Optional[float]</code> <p>Optional width of the line edges.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text label placed at <code>position</code>.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the OBB.  The class id provides colors and labels if not specified explicitly.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the bounding box will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/camera/","title":"camera.py","text":""},{"location":"package/rerun/log/camera/#rerun.log.camera","title":"<code>rerun.log.camera</code>","text":""},{"location":"package/rerun/log/camera/#rerun.log.camera.log_pinhole","title":"<code>def log_pinhole(entity_path, *, child_from_parent, width, height, timeless=False)</code>","text":"<p>Log a perspective camera model.</p> <p>This logs the pinhole model that projects points from the parent (camera) space to this space (image) such that: <pre><code>point_image_hom = child_from_parent * point_cam\npoint_image = point_image_hom[:,1] / point_image_hom[2]\n</code></pre></p> <p>Where <code>point_image_hom</code> is the projected point in the image space expressed in homogeneous coordinates.</p>"},{"location":"package/rerun/log/camera/#rerun.log.camera.log_pinhole--example","title":"Example","text":"<pre><code>width = 640\nheight = 480\nu_cen = width / 2\nv_cen = height / 2\nf_len = (height * width) ** 0.5\n\nrerun.log_pinhole(\"world/camera/image\",\n                  child_from_parent = [[f_len, 0,     u_cen],\n                                       [0,     f_len, v_cen],\n                                       [0,     0,     1  ]],\n                  width = width,\n                  height = height)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the child (image) space in the space hierarchy.</p> required <code>child_from_parent</code> <code>npt.ArrayLike</code> <p>Row-major intrinsics matrix for projecting from camera space to image space.</p> required <code>width</code> <code>int</code> <p>Width of the image in pixels.</p> required <code>height</code> <code>int</code> <p>Height of the image in pixels.</p> required <code>timeless</code> <code>bool</code> <p>If true, the camera will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/error_utils/","title":"error_utils.py","text":""},{"location":"package/rerun/log/error_utils/#rerun.log.error_utils","title":"<code>rerun.log.error_utils</code>","text":""},{"location":"package/rerun/log/extension_components/","title":"extension_components.py","text":""},{"location":"package/rerun/log/extension_components/#rerun.log.extension_components","title":"<code>rerun.log.extension_components</code>","text":""},{"location":"package/rerun/log/extension_components/#rerun.log.extension_components.log_extension_components","title":"<code>def log_extension_components(entity_path, ext, *, identifiers=None, timeless=False)</code>","text":"<p>Log an arbitrary collection of extension components.</p> <p>Each item in <code>ext</code> will be logged as a separate component.</p> <ul> <li>The key will be used as the name of the component</li> <li>The value must be able to be converted to an array of arrow types. In general, if    you can pass it to pyarrow.array,    you can log it as a extension component.</li> </ul> <p>All values must either have the same length, or be singular in which case they will be treated as a splat.</p> <p>Extension components will be prefixed with \"ext.\" to avoid collisions with rerun native components. You do not need to include this prefix; it will be added for you.</p> <p>Note: rerun requires that a given component only take on a single type. The first type logged will be the type that is used for all future logs of that component. The API will make a best effort to do type conversion if supported by numpy and arrow. Any components that can't be converted will be dropped.</p> <p>If you are want to inspect how your component will be converted to the underlying arrow code, the following snippet is what is happening internally: <pre><code>np_value = np.atleast_1d(np.array(value, copy=False))\npa_value = pa.array(value)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the extension components in the space hierarchy.</p> required <code>ext</code> <code>Dict[str, Any]</code> <p>A dictionary of extension components.</p> required <code>identifiers</code> <code>Optional[Sequence[int]]</code> <p>Optional identifiers for each component. If provided, must be the same length as the components.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the components will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/file/","title":"file.py","text":""},{"location":"package/rerun/log/file/#rerun.log.file","title":"<code>rerun.log.file</code>","text":""},{"location":"package/rerun/log/file/#rerun.log.file.MeshFormat","title":"<code>class MeshFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Mesh file format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.MeshFormat.GLB","title":"<code>GLB = 'GLB'</code>  <code>class-attribute</code>","text":"<p>glTF binary format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.MeshFormat.OBJ","title":"<code>OBJ = 'OBJ'</code>  <code>class-attribute</code>","text":"<p>Wavefront .obj format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.ImageFormat","title":"<code>class ImageFormat</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Image file format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.ImageFormat.JPEG","title":"<code>JPEG = 'jpeg'</code>  <code>class-attribute</code>","text":"<p>JPEG format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.log_mesh_file","title":"<code>def log_mesh_file(entity_path, mesh_format, mesh_file, *, transform=None, timeless=False)</code>","text":"<p>Log the contents of a mesh file (.gltf, .glb, .obj, \u2026).</p> <p>You can also use [<code>rerun.log_mesh</code>] to log raw mesh data.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.log_mesh_file--example","title":"Example:","text":"<pre><code># Move mesh 10 units along the X axis.\ntransform=np.array([\n    [1, 0, 0, 10],\n    [0, 1, 0, 0],\n    [0, 0, 1, 0]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>mesh_format</code> <code>MeshFormat</code> <p>Format of the mesh file</p> required <code>mesh_file</code> <code>bytes</code> <p>Contents of the mesh file</p> required <code>transform</code> <code>Optional[npt.ArrayLike]</code> <p>Optional 3x4 affine transform matrix applied to the mesh</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code>"},{"location":"package/rerun/log/file/#rerun.log.file.log_image_file","title":"<code>def log_image_file(entity_path, *, img_bytes=None, img_path=None, img_format=None, timeless=False)</code>","text":"<p>Log an image file given its contents or path on disk.</p> <p>Only JPEGs are supported right now.</p> <p>You must pass either <code>img_bytes</code> or <code>img_path</code>.</p> <p>If no <code>img_format</code> is specified, we will try and guess it.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>img_bytes</code> <code>Optional[bytes]</code> <p>Content of an image file, e.g. a <code>.jpg</code>.</p> <code>None</code> <code>img_path</code> <code>Optional[Path]</code> <p>Path to an image file, e.g. a <code>.jpg</code>.</p> <code>None</code> <code>img_format</code> <code>Optional[ImageFormat]</code> <p>Format of the image file.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/image/","title":"image.py","text":""},{"location":"package/rerun/log/image/#rerun.log.image","title":"<code>rerun.log.image</code>","text":""},{"location":"package/rerun/log/image/#rerun.log.image.log_image","title":"<code>def log_image(entity_path, image, *, ext=None, timeless=False)</code>","text":"<p>Log a gray or color image.</p> <p>The image should either have 1, 3 or 4 channels (gray, RGB or RGBA).</p>"},{"location":"package/rerun/log/image/#rerun.log.image.log_image--supported-dtypes","title":"Supported dtypes","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>uint16: color components should be in 0-65535 sRGB gamma space, except for alpha which should be in 0-65535 linear space.</li> <li>float32, float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the image to log.</p> required <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/image/#rerun.log.image.log_depth_image","title":"<code>def log_depth_image(entity_path, image, *, meter=None, ext=None, timeless=False)</code>","text":"<p>Log a depth image.</p> <p>The image must be a 2D array.</p>"},{"location":"package/rerun/log/image/#rerun.log.image.log_depth_image--supported-dtypes","title":"Supported dtypes","text":"<p>uint8, uint16, float32, float64</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the depth image to log.</p> required <code>meter</code> <code>Optional[float]</code> <p>How long is a meter in the given dtype? For instance: with uint16, perhaps meter=1000 which would mean you have millimeter precision and a range of up to ~65 meters (2^16 / 1000).</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/image/#rerun.log.image.log_segmentation_image","title":"<code>def log_segmentation_image(entity_path, image, *, ext=None, timeless=False)</code>","text":"<p>Log an image made up of integer class-ids.</p> <p>The image should have 1 channel, i.e. be either <code>H x W</code> or <code>H x W x 1</code>.</p> <p>See: rerun.log_annotation_context for information on how to map the class-ids to colors and labels.</p>"},{"location":"package/rerun/log/image/#rerun.log.image.log_segmentation_image--supported-dtypes","title":"Supported dtypes","text":"<p>uint8, uint16</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>npt.ArrayLike</code> <p>A Tensor representing the segmentation image to log.</p> required <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/imu/","title":"imu.py","text":""},{"location":"package/rerun/log/imu/#rerun.log.imu","title":"<code>rerun.log.imu</code>","text":""},{"location":"package/rerun/log/imu/#rerun.log.imu.log_imu","title":"<code>def log_imu(accel, gyro, orientation, mag=None)</code>","text":"<p>Log an IMU sensor reading.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <p>Path to the IMU sensor in the space hierarchy.</p> required <code>accel</code> <code>npt.ArrayLike</code> <p>Acceleration vector in m/s^2.</p> required <code>gyro</code> <code>npt.ArrayLike</code> <p>Angular velocity vector in rad/s.</p> required <code>orientation</code> <code>npt.ArrayLike</code> <p>Orientation quaternion.</p> required <code>mag</code> <code>Union[npt.ArrayLike, None]</code> <p>Magnetometer vector in uT.</p> <code>None</code>"},{"location":"package/rerun/log/lines/","title":"lines.py","text":""},{"location":"package/rerun/log/lines/#rerun.log.lines","title":"<code>rerun.log.lines</code>","text":""},{"location":"package/rerun/log/lines/#rerun.log.lines.log_line_strip","title":"<code>def log_line_strip(entity_path, positions, *, stroke_width=None, color=None, ext=None, timeless=False)</code>","text":"<p>Log a line strip through 2D or 3D space.</p> <p>A line strip is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so: <pre><code>       2------3     5\n      /        \\   /\n0----1          \\ /\n                 4\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the path in the space hierarchy</p> required <code>positions</code> <code>Optional[npt.ArrayLike]</code> <p>An Nx2 or Nx3 array of points along the path.</p> required <code>stroke_width</code> <code>Optional[float]</code> <p>Optional width of the line.</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the path will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/lines/#rerun.log.lines.log_line_segments","title":"<code>def log_line_segments(entity_path, positions, *, stroke_width=None, color=None, ext=None, timeless=False)</code>","text":"<p>Log many 2D or 3D line segments.</p> <p>The points will be connected in even-odd pairs, like so:</p> <pre><code>       2------3     5\n                   /\n0----1            /\n                 4\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the line segments in the space hierarchy</p> required <code>positions</code> <code>npt.ArrayLike</code> <p>An Nx2 or Nx3 array of points. Even-odd pairs will be connected as segments.</p> required <code>stroke_width</code> <code>Optional[float]</code> <p>Optional width of the line.</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the line segments will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/log_decorator/","title":"log_decorator.py","text":""},{"location":"package/rerun/log/log_decorator/#rerun.log.log_decorator","title":"<code>rerun.log.log_decorator</code>","text":""},{"location":"package/rerun/log/log_decorator/#rerun.log.log_decorator.log_decorator","title":"<code>def log_decorator(func)</code>","text":"<p>A decorator we add to all our logging function.</p> <p>It does two things: * It early-outs if logging is disabled * It catches any exceptions and logs them</p> <p>The latter is important in order not to crash the users application just because they misused the Rerun API (or because we have a bug!).</p>"},{"location":"package/rerun/log/mesh/","title":"mesh.py","text":""},{"location":"package/rerun/log/mesh/#rerun.log.mesh","title":"<code>rerun.log.mesh</code>","text":""},{"location":"package/rerun/log/mesh/#rerun.log.mesh.log_mesh","title":"<code>def log_mesh(entity_path, positions, *, indices=None, normals=None, albedo_factor=None, vertex_colors=None, timeless=False)</code>","text":"<p>Log a raw 3D mesh by specifying its vertex positions, and optionally indices, normals and albedo factor.</p> <p>You can also use [<code>rerun.log_mesh_file</code>] to log .gltf, .glb, .obj, etc.</p>"},{"location":"package/rerun/log/mesh/#rerun.log.mesh.log_mesh--example","title":"Example:","text":"<pre><code># A simple red triangle:\nrerun.log_mesh(\n    \"world/mesh\",\n    positions = [\n        [0.0, 0.0, 0.0],\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0]\n    ],\n    indices = [0, 1, 2],\n    normals = [\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, 1.0]\n    ],\n    albedo_factor = [1.0, 0.0, 0.0],\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>positions</code> <code>Any</code> <p>An array of 3D points. If no <code>indices</code> are specified, then each triplet of positions is interpreted as a triangle.</p> required <code>indices</code> <code>Optional[Any]</code> <p>If specified, is a flattened array of indices that describe the mesh's triangles, i.e. its length must be divisible by 3.</p> <code>None</code> <code>normals</code> <code>Optional[Any]</code> <p>If specified, is a (potentially flattened) array of 3D vectors that describe the normal for each vertex, i.e. the total number of elements must be divisible by 3 and more importantly, <code>len(normals)</code> should be equal to <code>len(positions)</code>.</p> <code>None</code> <code>albedo_factor</code> <code>Optional[Any]</code> <p>Optional color multiplier of the mesh using RGB or unmuliplied RGBA in linear 0-1 space.</p> <code>None</code> <code>vertex_colors</code> <code>Optional[Colors]</code> <p>Optional array of RGB(A) vertex colors, in sRGB gamma space, either as 0-1 floats or 0-255 integers. If specified, the alpha is considered separate (unmultiplied).</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code>"},{"location":"package/rerun/log/mesh/#rerun.log.mesh.log_meshes","title":"<code>def log_meshes(entity_path, position_buffers, *, vertex_color_buffers, index_buffers, normal_buffers, albedo_factors, timeless=False)</code>","text":"<p>Log multiple raw 3D meshes by specifying their different buffers and albedo factors.</p> <p>To learn more about how the data within these buffers is interpreted and laid out, refer to the documentation for [<code>rerun.log_mesh</code>].</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>position_buffers</code> <code>Sequence[npt.ArrayLike]</code> <p>A sequence of position buffers, one for each mesh.</p> required <code>vertex_color_buffers</code> <code>Sequence[Optional[Colors]]</code> <p>An optional sequence of vertex color buffers, one for each mesh.</p> required <code>index_buffers</code> <code>Sequence[Optional[npt.ArrayLike]]</code> <p>An optional sequence of index buffers, one for each mesh.</p> required <code>normal_buffers</code> <code>Sequence[Optional[npt.ArrayLike]]</code> <p>An optional sequence of normal buffers, one for each mesh.</p> required <code>albedo_factors</code> <code>Sequence[Optional[npt.ArrayLike]]</code> <p>An optional sequence of albedo factors, one for each mesh.</p> required <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code>"},{"location":"package/rerun/log/pipeline_graph/","title":"pipeline_graph.py","text":""},{"location":"package/rerun/log/pipeline_graph/#rerun.log.pipeline_graph","title":"<code>rerun.log.pipeline_graph</code>","text":""},{"location":"package/rerun/log/points/","title":"points.py","text":""},{"location":"package/rerun/log/points/#rerun.log.points","title":"<code>rerun.log.points</code>","text":""},{"location":"package/rerun/log/points/#rerun.log.points.log_point","title":"<code>def log_point(entity_path, position=None, *, radius=None, color=None, label=None, class_id=None, keypoint_id=None, ext=None, timeless=False)</code>","text":"<p>Log a 2D or 3D point, with a position and optional color, radii, label, etc.</p> <p>Logging again to the same <code>entity_path</code> will replace the previous point.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA represented as a 2-element or 3-element sequence.</p>"},{"location":"package/rerun/log/points/#rerun.log.points.log_point--supported-dtypes-for-color","title":"Supported dtypes for <code>color</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the point in the space hierarchy.</p> required <code>position</code> <code>Optional[npt.ArrayLike]</code> <p>Any 2-element or 3-element array-like.</p> <code>None</code> <code>radius</code> <code>Optional[float]</code> <p>Optional radius (make it a sphere).</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text to show with the point.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the point. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_id</code> <code>Optional[int]</code> <p>Optional key point id for the point, identifying it within a class. If keypoint_id is passed but no class_id was specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the point will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/points/#rerun.log.points.log_points","title":"<code>def log_points(entity_path, positions=None, *, identifiers=None, colors=None, radii=None, labels=None, class_ids=None, keypoint_ids=None, ext=None, timeless=False)</code>","text":"<p>Log 2D or 3D points, with positions and optional colors, radii, labels, etc.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous points.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"package/rerun/log/points/#rerun.log.points.log_points--supported-dtypes-for-colors","title":"Supported dtypes for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the points in the space hierarchy.</p> required <code>positions</code> <code>Optional[npt.ArrayLike]</code> <p>Nx2 or Nx3 array</p> <code>None</code> <code>identifiers</code> <code>Optional[npt.ArrayLike]</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Optional[Union[Color, Colors]]</code> <p>Optional colors of the points. The colors are interpreted as RGB or RGBA in sRGB gamma-space, as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>radii</code> <code>Optional[npt.ArrayLike]</code> <p>Optional radii (make it a sphere).</p> <code>None</code> <code>labels</code> <code>Optional[Sequence[str]]</code> <p>Optional per-point text to show with the points</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the points. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_ids</code> <code>OptionalKeyPointIds</code> <p>Optional key point ids for the points, identifying them within a class. If keypoint_ids are passed in but no class_ids were specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the points will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/rects/","title":"rects.py","text":""},{"location":"package/rerun/log/rects/#rerun.log.rects","title":"<code>rerun.log.rects</code>","text":""},{"location":"package/rerun/log/rects/#rerun.log.rects.RectFormat","title":"<code>class RectFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>How to specify rectangles (axis-aligned bounding boxes).</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XYWH","title":"<code>XYWH = 'XYWH'</code>  <code>class-attribute</code>","text":"<p>[x,y,w,h], with x,y = left,top.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.YXHW","title":"<code>YXHW = 'YXHW'</code>  <code>class-attribute</code>","text":"<p>[y,x,h,w], with x,y = left,top.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XYXY","title":"<code>XYXY = 'XYXY'</code>  <code>class-attribute</code>","text":"<p>[x0, y0, x1, y1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.YXYX","title":"<code>YXYX = 'YXYX'</code>  <code>class-attribute</code>","text":"<p>[y0, x0, y1, x1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XCYCWH","title":"<code>XCYCWH = 'XCYCWH'</code>  <code>class-attribute</code>","text":"<p>[x_center, y_center, width, height].</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XCYCW2H2","title":"<code>XCYCW2H2 = 'XCYCW2H2'</code>  <code>class-attribute</code>","text":"<p>[x_center, y_center, width/2, height/2].</p>"},{"location":"package/rerun/log/rects/#rerun.log.rects.log_rect","title":"<code>def log_rect(entity_path, rect, *, rect_format=RectFormat.XYWH, color=None, label=None, class_id=None, ext=None, timeless=False)</code>","text":"<p>Log a 2D rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangle in the space hierarchy.</p> required <code>rect</code> <code>Optional[npt.ArrayLike]</code> <p>the rectangle in [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text to show inside the rectangle.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the rectangle. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the rect will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/rects/#rerun.log.rects.log_rects","title":"<code>def log_rects(entity_path, rects, *, rect_format=RectFormat.XYWH, identifiers=None, colors=None, labels=None, class_ids=None, ext=None, timeless=False)</code>","text":"<p>Log multiple 2D rectangles.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous rectangles.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"package/rerun/log/rects/#rerun.log.rects.log_rects--supported-dtypes-for-colors","title":"Supported <code>dtype</code>s for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangles in the space hierarchy.</p> required <code>rects</code> <code>Optional[npt.ArrayLike]</code> <p>Nx4 numpy array, where each row is [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>identifiers</code> <code>Optional[Sequence[int]]</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Optional[Union[Color, Colors]]</code> <p>Optional per-rectangle gamma-space RGB or RGBA as 0-1 floats or 0-255 integers.</p> <code>None</code> <code>labels</code> <code>Optional[Sequence[str]]</code> <p>Optional per-rectangle text to show inside the rectangle.</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the rectangles. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the rects will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/scalar/","title":"scalar.py","text":""},{"location":"package/rerun/log/scalar/#rerun.log.scalar","title":"<code>rerun.log.scalar</code>","text":""},{"location":"package/rerun/log/scalar/#rerun.log.scalar.log_scalar","title":"<code>def log_scalar(entity_path, scalar, *, label=None, color=None, radius=None, scattered=None, ext=None)</code>","text":"<p>Log a double-precision scalar that will be visualized as a timeseries plot.</p> <p>The current simulation time will be used for the time/X-axis, hence scalars cannot be timeless!</p> <p>See here for a larger example.</p>"},{"location":"package/rerun/log/scalar/#rerun.log.scalar.log_scalar--understanding-the-plot-and-attributes-hierarchy","title":"Understanding the plot and attributes hierarchy","text":"<p>Timeseries come in three parts: points, lines and finally the plots themselves. As a user of the Rerun SDK, your one and only entrypoint into that hierarchy is through the lowest-level layer: the points.</p> <p>When logging scalars and their attributes (label, color, radius, scattered) through this function, Rerun will turn them into points with similar attributes. From these points, lines with appropriate attributes can then be inferred; and from these inferred lines, plots with appropriate attributes will be inferred in turn!</p> <p>In terms of actual hierarchy:</p> <ul> <li>Each space represents a single plot.</li> <li>Each entity path within a space that contains scalar data is a line within that plot.</li> <li>Each logged scalar is a point.</li> </ul> <p>E.g. the following: <pre><code>t=1.0\nrerun.log_scalar(\"trig/sin\", math.sin(t), label=\"sin(t)\", color=[255, 0, 0])\nrerun.log_scalar(\"trig/cos\", math.cos(t), label=\"cos(t)\", color=[0, 0, 255])\n</code></pre> will yield a single plot (space = <code>trig</code>), comprised of two lines (entity paths <code>trig/sin</code> and <code>trig/cos</code>).</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the scalar in the space hierarchy.</p> required <code>scalar</code> <code>float</code> <p>The scalar value to log.</p> required <code>label</code> <code>Optional[str]</code> <p>An optional label for the point.</p> <p>This won't show up on points at the moment, as our plots don't yet support displaying labels for individual points TODO(https://github.com/rerun-io/rerun/issues/1289). If all points within a single entity path (i.e. a line) share the same label, then this label will be used as the label for the line itself. Otherwise, the line will be named after the entity path. The plot itself is named after the space it's in.</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <p>If left unspecified, a pseudo-random color will be used instead. That same color will apply to all points residing in the same entity path that don't have a color specified.</p> <p>Points within a single line do not have to share the same color, the line will have differently colored segments as appropriate. If all points within a single entity path (i.e. a line) share the same color, then this color will be used as the line color in the plot legend. Otherwise, the line will appear grey in the legend.</p> <code>None</code> <code>radius</code> <code>Optional[float]</code> <p>An optional radius for the point.</p> <p>Points within a single line do not have to share the same radius, the line will have differently sized segments as appropriate.</p> <p>If all points within a single entity path (i.e. a line) share the same radius, then this radius will be used as the line width too. Otherwise, the line will use the default width of <code>1.0</code>.</p> <code>None</code> <code>scattered</code> <code>Optional[bool]</code> <p>Specifies whether the point should form a continuous line with its neighbors, or whether it should stand on its own, akin to a scatter plot. Points within a single line do not have to all share the same scatteredness: the line will switch between a scattered and a continuous representation as required.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code>"},{"location":"package/rerun/log/tensor/","title":"tensor.py","text":""},{"location":"package/rerun/log/tensor/#rerun.log.tensor","title":"<code>rerun.log.tensor</code>","text":""},{"location":"package/rerun/log/tensor/#rerun.log.tensor.Tensor","title":"<code>Tensor = Union[npt.ArrayLike, TorchTensorLike]</code>  <code>module-attribute</code>","text":"<p>Type helper for a tensor-like object that can be logged to Rerun.</p>"},{"location":"package/rerun/log/tensor/#rerun.log.tensor.TorchTensorLike","title":"<code>class TorchTensorLike</code>","text":"<p>         Bases: <code>Protocol</code></p> <p>Describes what is need from a Torch Tensor to be loggable to Rerun.</p>"},{"location":"package/rerun/log/tensor/#rerun.log.tensor.log_tensor","title":"<code>def log_tensor(entity_path, tensor, *, names=None, meter=None, ext=None, timeless=False)</code>","text":"<p>Log an n-dimensional tensor.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the tensor in the space hierarchy.</p> required <code>tensor</code> <code>npt.ArrayLike</code> <p>A Tensor object.</p> required <code>names</code> <code>Optional[Iterable[Optional[str]]]</code> <p>Optional names for each dimension of the tensor.</p> <code>None</code> <code>meter</code> <code>Optional[float]</code> <p>Optional scale of the tensor (e.g. meters per cell).</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the tensor will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/text/","title":"text.py","text":""},{"location":"package/rerun/log/text/#rerun.log.text","title":"<code>rerun.log.text</code>","text":""},{"location":"package/rerun/log/text/#rerun.log.text.LogLevel","title":"<code>class LogLevel</code>  <code>dataclass</code>","text":"<p>Represents the standard log levels.</p> <p>This is a collection of constants rather than an enum because we do support arbitrary strings as level (e.g. for user-defined levels).</p>"},{"location":"package/rerun/log/text/#rerun.log.text_internal.LogLevel.CRITICAL","title":"<code>CRITICAL: Final = 'CRITICAL'</code>  <code>class-attribute</code>","text":"<p>Designates catastrophic failures.</p>"},{"location":"package/rerun/log/text/#rerun.log.text_internal.LogLevel.ERROR","title":"<code>ERROR: Final = 'ERROR'</code>  <code>class-attribute</code>","text":"<p>Designates very serious errors.</p>"},{"location":"package/rerun/log/text/#rerun.log.text_internal.LogLevel.WARN","title":"<code>WARN: Final = 'WARN'</code>  <code>class-attribute</code>","text":"<p>Designates hazardous situations.</p>"},{"location":"package/rerun/log/text/#rerun.log.text_internal.LogLevel.INFO","title":"<code>INFO: Final = 'INFO'</code>  <code>class-attribute</code>","text":"<p>Designates useful information.</p>"},{"location":"package/rerun/log/text/#rerun.log.text_internal.LogLevel.DEBUG","title":"<code>DEBUG: Final = 'DEBUG'</code>  <code>class-attribute</code>","text":"<p>Designates lower priority information.</p>"},{"location":"package/rerun/log/text/#rerun.log.text_internal.LogLevel.TRACE","title":"<code>TRACE: Final = 'TRACE'</code>  <code>class-attribute</code>","text":"<p>Designates very low priority, often extremely verbose, information.</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LoggingHandler","title":"<code>class LoggingHandler(root_entity_path=None)</code>","text":"<p>         Bases: <code>logging.Handler</code></p> <p>Provides a logging handler that forwards all events to the Rerun SDK.</p> <p>Because Rerun's data model doesn't match 1-to-1 with the different concepts from python's logging ecosystem, we need a way to map the latter to the former:</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LoggingHandler--mapping","title":"Mapping","text":"<ul> <li> <p>Root Entity: Optional root entity to gather all the logs under.</p> </li> <li> <p>Entity path: the name of the logger responsible for the creation of the LogRecord                is used as the final entity path, appended after the Root Entity path.</p> </li> <li> <p>Level: the log level is mapped as-is.</p> </li> <li> <p>Body: the body of the text entry corresponds to the formatted output of         the LogRecord using the standard formatter of the logging package,         unless it has been overridden by the user.</p> </li> </ul> <p>Read more about logging handlers</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LoggingHandler.emit","title":"<code>def emit(record)</code>","text":"<p>Emits a record to the Rerun SDK.</p>"},{"location":"package/rerun/log/text/#rerun.log.text.log_text_entry","title":"<code>def log_text_entry(entity_path, text, *, level=LogLevel.INFO, color=None, ext=None, timeless=False)</code>","text":"<p>Log a text entry, with optional level.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The object path to log the text entry under.</p> required <code>text</code> <code>str</code> <p>The text to log.</p> required <code>level</code> <code>Optional[str]</code> <p>The level of the text entry (default: <code>LogLevel.INFO</code>). Note this can technically be an arbitrary string, but it's recommended to use one of the constants from LogLevel</p> <code>LogLevel.INFO</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>ext</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>Whether the text entry should be timeless.</p> <code>False</code>"},{"location":"package/rerun/log/text_internal/","title":"text_internal.py","text":""},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal","title":"<code>rerun.log.text_internal</code>","text":""},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.LogLevel","title":"<code>class LogLevel</code>  <code>dataclass</code>","text":"<p>Represents the standard log levels.</p> <p>This is a collection of constants rather than an enum because we do support arbitrary strings as level (e.g. for user-defined levels).</p>"},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.LogLevel.CRITICAL","title":"<code>CRITICAL: Final = 'CRITICAL'</code>  <code>class-attribute</code>","text":"<p>Designates catastrophic failures.</p>"},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.LogLevel.ERROR","title":"<code>ERROR: Final = 'ERROR'</code>  <code>class-attribute</code>","text":"<p>Designates very serious errors.</p>"},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.LogLevel.WARN","title":"<code>WARN: Final = 'WARN'</code>  <code>class-attribute</code>","text":"<p>Designates hazardous situations.</p>"},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.LogLevel.INFO","title":"<code>INFO: Final = 'INFO'</code>  <code>class-attribute</code>","text":"<p>Designates useful information.</p>"},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.LogLevel.DEBUG","title":"<code>DEBUG: Final = 'DEBUG'</code>  <code>class-attribute</code>","text":"<p>Designates lower priority information.</p>"},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.LogLevel.TRACE","title":"<code>TRACE: Final = 'TRACE'</code>  <code>class-attribute</code>","text":"<p>Designates very low priority, often extremely verbose, information.</p>"},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.log_text_entry_internal","title":"<code>def log_text_entry_internal(entity_path, text, *, level=LogLevel.INFO, color=None, timeless=False)</code>","text":"<p>Internal API to log a text entry, with optional level.</p> <p>This implementation doesn't support extension components, or the exception-capturing decorator and is intended to be used from inside the other rerun log functions.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The object path to log the text entry under.</p> required <code>text</code> <code>str</code> <p>The text to log.</p> required <code>level</code> <code>Optional[str]</code> <p>The level of the text entry (default: <code>LogLevel.INFO</code>). Note this can technically be an arbitrary string, but it's recommended to use one of the constants from LogLevel</p> <code>LogLevel.INFO</code> <code>color</code> <code>Optional[Color]</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>Whether the text entry should be timeless.</p> <code>False</code>"},{"location":"package/rerun/log/transform/","title":"transform.py","text":""},{"location":"package/rerun/log/transform/#rerun.log.transform","title":"<code>rerun.log.transform</code>","text":"<p>Methods for logging transforms on entity paths.</p> <p>Learn more about transforms in the manual</p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_view_coordinates","title":"<code>def log_view_coordinates(entity_path, *, xyz='', up='', right_handed=None, timeless=False)</code>","text":"<p>Log the view coordinates for an entity.</p> <p>Each entity defines its own coordinate system, called a space. By logging view coordinates you can give semantic meaning to the XYZ axes of the space. This is for example useful for camera entities (\"what axis is forward?\").</p> <p>For full control, set the <code>xyz</code> parameter to a three-letter acronym (<code>xyz=\"RDF\"</code>). Each letter represents:</p> <ul> <li>R: Right</li> <li>L: Left</li> <li>U: Up</li> <li>D: Down</li> <li>F: Forward</li> <li>B: Back</li> </ul> <p>Some of the most common are:</p> <ul> <li>\"RDF\": X=Right Y=Down Z=Forward  (right-handed)</li> <li>\"RUB\"  X=Right Y=Up   Z=Back     (right-handed)</li> <li>\"RDB\": X=Right Y=Down Z=Back     (left-handed)</li> <li>\"RUF\": X=Right Y=Up   Z=Forward  (left-handed)</li> </ul>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_view_coordinates--example","title":"Example","text":"<pre><code>rerun.log_view_coordinates(\"world/camera\", xyz=\"RUB\")\n</code></pre> <p>For world-coordinates it's often convenient to just specify an up-axis. You can do so by using the <code>up</code>-parameter (where <code>up</code> is one of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\"):</p> <pre><code>rerun.log_view_coordinates(\"world\", up=\"+Z\", right_handed=True, timeless=True)\nrerun.log_view_coordinates(\"world\", up=\"-Y\", right_handed=False, timeless=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path in the space hierarchy where the view coordinate will be set.</p> required <code>xyz</code> <code>str</code> <p>Three-letter acronym for the view coordinate axes.</p> <code>''</code> <code>up</code> <code>str</code> <p>Which axis is up? One of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\".</p> <code>''</code> <code>right_handed</code> <code>Optional[bool]</code> <p>If True, the coordinate system is right-handed. If False, it is left-handed.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the view coordinates will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_unknown_transform","title":"<code>def log_unknown_transform(entity_path, timeless=False)</code>","text":"<p>Log that this entity is NOT in the same space as the parent, but you do not (yet) know how they relate.</p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_rigid3","title":"<code>def log_rigid3(entity_path, *, parent_from_child=None, child_from_parent=None, xyz='', timeless=False)</code>","text":"<p>Log a proper rigid 3D transform between this entity and the parent.</p> <p>Set either <code>parent_from_child</code> or <code>child_from_parent</code> to a tuple of <code>(translation_xyz, quat_xyzw)</code>.</p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_rigid3--parent-from-child","title":"Parent-from-child","text":"<p>Also known as pose (e.g. camera extrinsics).</p> <p>The translation is the position of the entity in the parent space. The resulting transform from child to parent corresponds to taking a point in the child space, rotating it by the given rotations, and then translating it by the given translation:</p> <p><code>point_parent = translation + quat * point_child * quat*</code></p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_rigid3--example","title":"Example","text":"<pre><code>t = 0.0\ntranslation = [math.sin(t), math.cos(t), 0.0] # circle around origin\nrotation = [0.5, 0.0, 0.0, np.sin(np.pi/3)] # 60 degrees around x-axis\nrerun.log_rigid3(\"sun/planet\", parent_from_child=(translation, rotation))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path of the child space in the space hierarchy.</p> required <code>parent_from_child</code> <code>Optional[Tuple[npt.ArrayLike, npt.ArrayLike]]</code> <p>A tuple of <code>(translation_xyz, quat_xyzw)</code> mapping points in the child space to the parent space.</p> <code>None</code> <code>child_from_parent</code> <code>Optional[Tuple[npt.ArrayLike, npt.ArrayLike]]</code> <p>the inverse of <code>parent_from_child</code></p> <code>None</code> <code>xyz</code> <code>str</code> <p>Optionally set the view coordinates of this entity, e.g. to <code>RDF</code> for <code>X=Right, Y=Down, Z=Forward</code>. This is a convenience for also calling log_view_coordinates.</p> <code>''</code> <code>timeless</code> <code>bool</code> <p>If true, the transform will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun_demo/__init__/","title":"__init__.py","text":""},{"location":"package/rerun_demo/__init__/#rerun_demo","title":"<code>rerun_demo</code>","text":"<p>The <code>rerun_demo</code> package contains utilities for easily demonstrating rerun features.</p> <p>main.py is a program which tries to load a pre-baked .rrd file into the viewer</p> <p>The <code>data</code> module contains a collection of reference objects and helpers that can be easily logged with a few lines of code, but still produce visually interesting content.</p> <p>As an example, consider: <pre><code>import rerun as rr\nfrom rerun_demo.data import color_grid\n\nrr.init(\"log_points\", True)\n\nrr.log_points(\"my_points\", color_grid.positions, colors=color_grid.colors)\n</code></pre></p> <p>Note that because this package is shipped with the depthai-viewer pypi package, it cannot carry any dependencies beyond those of rerun itself. This generally limits demos to only using the standard library and numpy for data generation.</p>"},{"location":"package/rerun_demo/data/","title":"data.py","text":""},{"location":"package/rerun_demo/data/#rerun_demo.data","title":"<code>rerun_demo.data</code>","text":"<p>Simple data to be used for Rerun demos.</p>"},{"location":"package/rerun_demo/data/#rerun_demo.data.color_grid","title":"<code>color_grid = build_color_grid()</code>  <code>module-attribute</code>","text":"<p>Default color grid</p>"},{"location":"package/rerun_demo/data/#rerun_demo.data.rect_pyramid","title":"<code>rect_pyramid = build_rect_pyramid()</code>  <code>module-attribute</code>","text":"<p>Default rect pyramid data</p>"},{"location":"package/rerun_demo/data/#rerun_demo.data.color_spiral","title":"<code>color_spiral = build_color_spiral()</code>  <code>module-attribute</code>","text":"<p>Default color spiral</p>"},{"location":"package/rerun_demo/data/#rerun_demo.data.build_color_grid","title":"<code>def build_color_grid(x_count=10, y_count=10, z_count=10, twist=0)</code>","text":"<p>Create a cube of points with colors.</p> <p>The total point cloud will have x_count * y_count * z_count points.</p> <p>Parameters:</p> Name Type Description Default <code>x_count</code> <p>Number of points in each dimension.</p> <code>10</code> <code>y_count</code> <p>Number of points in each dimension.</p> <code>10</code> <code>z_count</code> <p>Number of points in each dimension.</p> <code>10</code> <code>twist</code> <p>Angle to twist from bottom to top of the cube</p> <code>0</code>"},{"location":"package/rerun_demo/data/#rerun_demo.data.build_rect_pyramid","title":"<code>def build_rect_pyramid(count=20, width=100, height=100)</code>","text":"<p>Create a stack of N colored rectangles.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <p>Number of rectangles to create.</p> <code>20</code> <code>width</code> <p>Width of the base of the pyramid.</p> <code>100</code> <code>height</code> <p>Height of the pyramid.</p> <code>100</code>"},{"location":"package/rerun_demo/data/#rerun_demo.data.build_color_spiral","title":"<code>def build_color_spiral(num_points=100, radius=2, angular_step=0.02, angular_offset=0, z_step=0.1)</code>","text":"<p>Create a spiral of points with colors along the Z axis.</p> <p>Parameters:</p> Name Type Description Default <code>num_points</code> <p>Total number of points.</p> <code>100</code> <code>radius</code> <p>The radius of the spiral.</p> <code>2</code> <code>angular_step</code> <p>The factor applied between each step along the trigonemetric circle.</p> <code>0.02</code> <code>angular_offset</code> <p>Offsets the starting position on the trigonemetric circle.</p> <code>0</code> <code>z_step</code> <p>The factor applied between between each step along the Z axis.</p> <code>0.1</code>"},{"location":"package/rerun_demo/turbo/","title":"turbo.py","text":""},{"location":"package/rerun_demo/turbo/#rerun_demo.turbo","title":"<code>rerun_demo.turbo</code>","text":""},{"location":"package/rerun_demo/util/","title":"util.py","text":""},{"location":"package/rerun_demo/util/#rerun_demo.util","title":"<code>rerun_demo.util</code>","text":"<p>Simpe utilities to be used for Rerun demos.</p>"},{"location":"package/rerun_demo/util/#rerun_demo.util.bounce_lerp","title":"<code>def bounce_lerp(a, b, t)</code>","text":"<p>A linear interpolator that bounces between <code>a</code> and <code>b</code> as <code>t</code> goes above <code>1.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <p>Start value (t == 0).</p> required <code>b</code> <p>End value (t == 1).</p> required <code>t</code> <p>Interpolation coefficient.</p> required"},{"location":"package/rerun_demo/util/#rerun_demo.util.interleave","title":"<code>def interleave(arr1, arr2)</code>","text":"<p>Interleaves two numpy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>arr1</code> <p>A numpy array of arbitrary shape and length.</p> required <code>arr2</code> <p>A numpy array with the same shape and length as <code>arr1</code>.</p> required"}]}